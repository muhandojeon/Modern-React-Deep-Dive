## SPA

- 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식.
- `history` 객체의 `pushState` `replaceState`로 페이지를 전환한다.
- 페이지의 소스를 까보면 HTML이 텅텅 비어있다. `<body/>`의 내용을 자바스크립트 코드로 삽입하고 나서 렌더링하기 때문임.
- 이미 갖고있는 자바스크립트 리소스와 브라우저 API를 기반으로 모든 작동이 이루어짐.
- 최초 로딩해야할 자바스크립트 리소스가 커지는 단점이 있지만, 한 번 로딩된 이후에는 서보 통신이 적어지기 때문에 UX 장점을 가짐.
- 왜 SPA가 대세가 된건가?
  - 예전에는 대부분 서버사이드 렌더링이었음. 서버에서 다 그려서 보내주고, 자바스크립트는 단순 보조수단.
  - 자바스크립트가 보조수단에서 역할이 점점 커지게 되면서 모듈화(ESM, CJS) 방안에 대한 논의가 이루어짐.
  - 모듈화, 기기 성능 향상, 인터넷 속도 발전을 계기로 자바스크립트 입지가 커짐.
  - 자바스크립트로 MV~ 프레임워크 구현이 시작되고, 지금까지 이어짐

## MPA

- 페이지 전환이 발생할 때마다 새롭게 페이지를 요청(HTML을 새로 받아옴)
- 페이지를 처음부터 새로 그려야 해서 페이지 전환시 부자연스러운 흰 화면을 보게 된다.

## 웹 개발의 변화

- 많은 양의 리소스가 자바스크립트로 넘어오면서 번들은 점점 커진다.
- 기기 성능이 예전에 비해 많이 좋아져서 괜찮을까?
  - 자바스크립트 리소스 크기는 계속해서 증가하고 있음.(12년 대비 100배 증가)
  - 스크립트가 페이지당 소비하는 CPU 시간도 계속해서 증가함.(17년 대비 3배 증가)
  - TTI 15초(?) 무슨 페이지로 테스트한거니...
- 어쨌든, 웹 서비스가 많은 작업을 처리하게 되면서 기기가 좋아져도 사용자가 느끼는 로딩 속도는 5년 전이나 지금이나 별 차이가 없다.

## SSR

### 장점

- 렌더링에 필요한 작업을 서버에서 수행한다.
- CSR과 달리 기기 성능에 영향을 받지 않는다.
- 최초 페이지 진입이 비교적 빠르다
  - 최초 페이지 진입 시 유의미한 정보가 그려지는 시간(First Contentful Paint)이 더 빨라질 수 있다.
  - 일반적으로 서버에서 HTTP 요청을 수행하는 것이 더 빠르며, HTML을 그리는 작업도 서버에서 해당 HTML을 문자열로 미리 그려서 내려주는 것이 클라이언트에서 기존 HTML에 삽입하는 것보다 더 빠르기 때문이다.
- SEO
- 누적 레이아웃 이동이 적다
  - 누적 레이아웃 이동이란 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥 거리는 것과 같은 부정적인 사용자 경험을 말함
  - 지난 회사에서 만들었던 툴팁 컴포넌트가 이 문제때문에 매우 고생함...
- 보안에 좀 더 안전하다

### 단점

- 코드를 작성할 때 항상 서버를 고려해야 한다.
  - window 전역 객체 없는것... useEffect 사용하기...
- 적절한 서버가 구축돼 있어야 한다
  - vercel 안쓰면...?
- 서비스 지연에 따른 문제
  - 서버사이드의 작업이 길어지면 사용자는 그 동안 아무 것도 보지 못함.

### SSR은 만능이 아니다

- 가장 뛰어난 SPA는 가장 뛰어난 MPA보다 낫다.
- 평균적인 SPA는 평균적인 MPA보다 느리다. 그러나 MPA가 더 나을수도...
  - 페인트 홀딩: 같은 출처에서 라우팅이 일어날 경우 화면을 잠깐 하얗게 띄우는 대신 이전 페이지 모습을 보여주는 기법
  - back forward cache: 브라우저 앞으로 가기, 뒤로가기 실행 시 캐시된 페이지를 보여주는 기법
  - Shared Element Transition: 라우팅이 일어났을 때 두 페이지에 동일 요소가 있다면 부드럽게 전환되게 하는 기법

### 현대의 서버 사이드 렌더링

- 최초 웹사이트 진입 시에는 SSR로, 이후 라우팅은 서버에서 내려받은 자바스크립트를 바탕으로 SPA처럼 작동한다.

## 서버 사이드 렌더링을 위한 리액트 API

- 리액트는 브라우저 환경 뿐만 아니라 노드 서버 환경에서 렌더링할 수 있는 API도 제공한다.

### renderToString

- 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수
- 최초의 페이지를 HTML로 먼저 렌더링하는데, 이 역할을 담당함.
- 브라우저가 렌더링할 수 있는 HTML을 빠르게 제공하기 위해 훅, 이벤트 핸들러와 같은 자바스크립트 코드는 결과물에 포함되지 않는다.
- 실제로 페이지가 사용자와 인터랙션할 준비가 되기 위해서는 자바스크립트를 별도로 다운로드, 파싱, 실행하는 과정을 거쳐야 한다.
- `data-reactroot`는 리액트 컴포넌트의 루트 엘리먼트를 식별하고, hydrate 함수에서 루트를 식별하는 기준점으로 기능한다.

### renderToStaticMarkup

- renderToString과 매우 유사하다.
- HTML 문자열을 만들지만, `data-reactroot` 와 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다.
- 이를 통해 HTML의 크기를 아주 약간이라도 줄일 수 있다.
- 대신 useEffect와 같은 브라우저 API를 절대로 실행할 수 없다.
- hydrate를 수행하지 않는다는 가정하에 작동하는 것임
- 이벤트 리스너도 필요 없는 완전히 순수한 HTML을 만들 때만 사용된다.

### renderToNodeStream

- renderToString과 완전 동일한 결과물을 갖는다.
- 단, 브라우저에서 사용할 수 없는 API다.
- 결과물의 타입이 Node.js의 ReadableStream 타입이다. (renderToString의 결과물은 string이다.)
  - ReadableStream은 utf-8로 인코딩된 바이트 스트림으로, 노드 환경에서만 사용할 수 있다.
    - ReadableStream은 브라우저에서도 사용할 수 있는 객체지만 만드는 과정이 브라우저에서 불가능하게 구현돼 있다.
- renderToNodeStream이 필요한 이유는 뭘까?
  - 만약 renderToString이 생성하는 HTML 결과물의 크기가 엄청 크다면? string을 한 번에 메모리에 올려두고 응답을 수행하면 서버에 부담이 될 수 있다.
  - 따라서 이를 청크 단위로 분리해 순차적으로 처리한다.
  - 예를 들어, 엄청나게 많은 수의 list를 렌더링하는 경우?
  - **그럼 네트워크 응답 코드는 206일까?**
  - **그럼 청크의 단위는 개발자가 설정할 수 있는걸까? like 웹팩의 코드스플리팅?**
- 대부분의 리액트 SSR 프레임워크는 renderToNodeStream을 채택하고 있다.

### renderToStaticNodeStream

- renderToNodeStream과 동일하지만 `data-reactroot`와 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다.
- 따라서 hydrate를 할 필요가 없는 순수 HTML 결과물이 필요할 때 사용하는 메서드.

### hydrate

- renderToString, renderToNodeStream으로 생성된 HTML에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.
- 브라우저에서만 사용되는 메서드인 render와 매우 비슷한 형태로 사용한다.
- `ReactDOM.render(<App />, rootElement)` `ReactDOM.hydrate(<App />, rootElement)`
- 차이점은 hydrate는 이미 렌더링된 HTML이 있을 경우, 해당 HTML을 기준으로 이벤트를 붙이는 작업만 실행한다는 것.

  - render는 아무것도 없는 빈 HTML에 정보를 렌더링한다.
  - 만약 renderToStaticMarkup로 생성된 순수한 HTML을 hydrate에 넘겨준다면...? 예시 기준으로 rootElement에 `<App />`이 없는 상태라서 워닝이 발생할 것이다.
    - 단, 워닝이 발생하긴 하는데 잘 그려지긴 한다. 이유는 hydrate가 넘겨받은 HTML과 직접 렌더링한 HTML을 비교하는 과정이 있는데, 워닝은 이 비교 과정에서 발생하는 것이고 비교 결과가 다르다면 hydrate가 렌더링한 기준으로 웹페이지를 그리기 때문.
    - **그 말은... hydrate는 클라이언트에서 동작하는 메서드라는 거져?**

- 서버사이드 프레임워크 만들기 예제 개꿀 279p~

## Next.js 톺아보기

- 페이스북에서 리액트 기반 SSR을 위해 `react-page` 프로젝트를 고려했었다. 지금은 중지.
- next는 거기서 영감을 받은 것으로 보임.
  - 디렉토리 구조가 url로 변환되는 것이 `react-page` 에서 이미 구현해놨던 기능이라고 함.
- `eslint-config-next` : 구글과 협업해 만든 웹 바이탈 관련 규칙이 내장되어 있다.

### next.config.js

- next 프로젝트의 환경 설정을 담당한다.
- ExperimentalConfig에 뭔가 엄청나게 많은 옵션이 존재하는데 유용한게 있을지도 모르겠다.

### pages/\_app.tsx

- 앱 전체 페이지의 시작점.
- 따라서 앱 공통으로 설정해야 하는 것들을 여기에서 실행할 수 있다.
  - 에러 바운더리를 사용하여 전역 에러 처리
  - reset.css와 같은 전역 css 선언
  - 모든 페이지에 공통으로 사용 또는 제공해야 하는 데이터 제공
- 여기의 render안에서 console.log()를 실행하면 브라우저 콘솔이 아닌 터미널에 찍힌다.
  - 페이지를 전환하면 브라우저에 찍힌다.
  - 즉, 최초에는 SSR, 이후에는 CSR로 작동한다는 것을 알 수 있다.

### pages/\_document.tsx

- `_app.tsx`가 앱 페이저 전체를 초기화하는 곳이라면 `_document.tsx`는 앱의 HTML을 초기화하는 곳이다.
- `<html>`이나 `<body>`에 DOM 속성을 추가하고 싶다면 `_document.tsx`를 사용한다.
- `_document.tsx`는 무조건 서버에서 실행된다. 따라서 여기에서 이벤트 핸들러를 추가하는 것은 불가능하다. 이벤트를 추가하는 것은 클라이언트에서 실행되는 hydrate의 몫이기 때문이다.
- next에는 `next/document` `next/head` 각각 head가 있다.
  - `next/document`의 head는 `_document.tsx`에서만 사용할 수 있다.
  - 단, `next/document`의 head에서는 `<title>`를 사용할 수 없다. 페이지 공통 제목을 사용하려면 `_app.tsx`에서 설정해주자.
- CSS-in-JS의 스타일을 서버에서 모아 HTML로 제공하는 작업을 수행한다.

### pages/\_error.tsx

- next 프로젝트 전역에서 발생하는 에러를 처리하기 위한 페이지.
- 클라이언트에서 발생하는 에러와 서버에서 발생하는 500 에러를 처리하는 목적.
- 개발 모드에서는 방문할 수 없고, 확인하려면 프로덕션으로 빌드해서 확인해 봐야 한다.

### pages/404.tsx

- 404페이지를 정의하는 파일이다.

### pages/500.tsx

- 서버에서 발생하는 에러를 처리하는 페이지다.
- `pages/_error.tsx`와 함께 있다면 `pages/500.tsx`가 우선된다.

### pages/index.tsx

- 디렉토리 구조가 곧 url이 된다.
- `pages/hi/[...props].tsx`라면? hi 하위의 모든 주소가 해당 파일로 떨어진다. `/hi/hello/world/foo`
  - props 배열에 주소가 문자열로 들어간다. getServerSideProps를 써서 가져올 수 있음.
- next의 장점인 최초에는 SSR, 이후는 CSR방식으로 라우팅하는 것을 살리려면 next/link와 router를 잘 사용하자.
- **만약 함수에서 router.push를 쓰고싶으면 어떡해야하나?**
- `getServerSideProps`가 없다면 서버에서 실행하지 않아도 되는 정적 페이지로 간주한다.
  - typeof window를 모두 object로 바꾸고 빌드 시점에 트리쉐이킹 해버린다.
  - **먼소리지... SSG라는 건가? 그대로 완성된 정적 페이지 넘겨줘버리고 서버에선 아무것도 안한다는 뜻? 이후에 클라에서 hydrate만 한번 돌리나...??**

## Data Fetching

### getStaticPath, getStaticProps

- SSG용 함수
- 세트로 사용한다.
  - 페이지가 하나인 프로젝트에선 getStaticPath를 안써도 된다(?)
    - 내 이력서는 잘 됨 ㅋ 다른 페이지가 없어서...
  - getStaticPath는 어떤 페이지를 허용할 것인가, getStaticProps는 페이지에서 사용할 데이터 요청을 수행
  - 페이지를 모조리 빌드해 두고 배포하면 사용자는 페이지가 렌더링되는 것을 기다릴 필요 없이 완성된 페이지를 받기만 하면 되므로 굉장히 빠르게 페이지를 확인할 수 있다.
    - **그 말은... 완성된 HTML을 브라우저가 그리는 레이아웃~페인트 요런 단계들은 속도에서 차지하는 비중이 별로 없다는 건가?**

### getServerSideProps

- 서버에서 실행되는 함수다.
- 해당 함수가 있다면 무조건 페이지 진입 전에 이 함수를 실행한다.
- 응답값에 따라 다른 페이지로 리다이렉트 가능
  - 회사에서 요걸로 접근 제한(withAuth) 서버사이드 함수를 만들어서 사용중
- getServerSideProps에서 fetch하는 상황을 가정하면... 서버에서 한 번, 클라에서 한 번 비효율적으로 두 번 fetch하는 상황을 막고 서버와 클라의 fetch 결과물 불일치를 막기 위해 script로 서버에서 fetch해온 prop을 적어두고 재활용한다.
  - 따라서 getServerSideProps의 props는 직렬화 가능한 JSON 데이터다.
- 여기서 에러가 발생하면 서버 에러라서 500.tsx가 보일 것임

### getInitialProps

- 대부분의 경우에서 권장되지 않는다.
- 모든 페이지에서 진입시 반드시 실행되게 하려고 작성할까 했었는데 공식문서에서도 쓰지말라고 적혀있었던 것으로 기억함.

## 스타일 적용하기

### 전역 스타일

- `reset.css`를 적용하려면 `_app.tsx`에서 하자.

### 컴포넌트 레벨 CSS

### SCSS SASS

### CSS-in-JS(styled-components)

- 사용하기 위해서는 보일러 플레이트가 복잡.
- 리액트 트리 내부에서 사용하고 있는 styled-components의 스타일을 모두 모은 다음, 각각의 스타일에 유니크한 클래스명을 부여해 스타일이 충돌하지 않게 클래스명과 스타일을 정리해 이를 `_document.tsx`가 서버에서 렌더링할 때 React.Context 형태로 제공한다.
- 이렇게 스타일을 서버에서 미리 모은 다음 SSR에서 한꺼번에 제공해야 올바른 스타일을 적용할 수 있다.
- 이런 과정을 거치지 않는다면 스타일이 브라우저에서 요소가 그려지는 것보다 뒤늦게 적용되어 FOUC(flash of unstyled content)가 발생한다.
- 프로덕션 빌드 시 `<style/>` 태그 내부가 비어 있는데, 스타일은 정상적으로 적용되어 있다.
  - styled-components가 개발 모드와 다르게 프로덕션 모드에서는 `SPEEDY_MODE`라고 하는 설정을 사용하기 때문이다.
  - 속도를 위해 HTML에 스타일을 적용하지 않고, 자바스크립트를 활용해 CSSOM 트리에 직접 스타일을 넣는다.
