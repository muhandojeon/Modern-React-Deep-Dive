- 9.1 Next.js로 리액트 개발 환경 구축하기
  - 작성해야 하는 파일
    - Node.js 프로젝트이므로 package.json
    - 타입스크립트 사용을 위한 tsconfig.json
      - `”$schema”: “https://json.schemastore.org/tsconfig.json`
        - tsconfig 작성 시 자동 완성 가능해짐
      - 옵션
        - compilerOptions
          - jsx: .tsx 파일 내부의 JSX를 어떻게 컴파일할지 설정
            - react
            - react-jsx, react-jsxdev
            - preserve
              - Next.js의 경우 swc가 JSX까지 변환해주기 때문에 preserve를 사용할 수 있다.
- 9.2 깃허브 100% 활용하기
  - 깃허브 액션
    - CI의 핵심: 저장소 코드에 변화가 있을 때마다 전체 소프트웨어의 정합성을 확인하기 위한 작업을 자동으로 실행. 필요한 작업은 테스트, 필드, 정적 분석, 보약 취약점 분석 등.
    - 깃허브에서 일어나는 다양한 액션을 트리거로 사용자가 원하는 작업을 수행할 수 있도록 도와주는 서비스이다.
    - 기본 개념
      - 러너
        - 깃허브 액션이 실행되는 서버. 지정하지 않을 경우 공용 깃허브 액션 서버를 이용한다. 자체적으로 별도의 러너를 구축할 수도 있다.
      - 이벤트
        - schedule: 특정 시간에 특정 작업을 실행할 수 있다.
    - 브랜치에 머지 전 꼭 성공해야 하는 옵션이 있다면 저장소에서 브랜치 보호 규칙 추가하기
  - 깃허브 Dependabot으로 보안 취약점 해결하기
    - 의존성에 문제가 있다면 문제를 알려주고, 가능하다면 해결할 수 있는 PR까지 열어주는 깃허브의 기능. 프로젝트의 보안 위협을 제거할 수 있다.
    - dependencies 이해하기
      - 유의적 버전(semantic versioning)
        - 버전은 주.부.수로 구성되어 있다.
          - 주: 기존 버전과 호환되지 않게 API가 바뀌면 주 버전을 올린다.
          - 부: 기존 버전과 호환되면서 새로운 기능을 추가할 때는 부 버전을 올린다.
          - 수: 기존 버전과 호환되면서 버그를 수정했다면 수 버전을 올린다.
            - 버그 수정이 API 스펙을 동원하는 경우 주 버전을 올려야 한다. 주 버전을 올리기 어렵다면 해당 API를 deprecated 처리하고, 새로운 API를 만들어 부 버전을 올리는 게 좋다.
        - npm의 버전 규칙
          - react@16.0.0: 정확히 16.0.0 버전에 의존
          - react@^16.0.0: 16.0.0과 호환되는 버전. 16.0.0부터 17.0.0 미만의 모든 버전.
          - react@~16.0.0: 패치 버전에 대해서만 호환되는 버전. 16.0.0부터 16.1.0 미만의 모든 버전.
        - 유의적 버전은 개발자 간의 약속일 뿐, 그 자체가 실제 API가 유의적 버전에 맞게 구현되었다는 사실을 보장하지는 않는다. 하지만 버전을 보고 얼마나 중요한 변경사항이 있었는지를 짐작해볼 수는 있다.
          - 가령 수 버전만 올라간 경우 단순 패치 수정일 것이므로 올리더라도 기능상에 큰 문제는 없을 것이다.
      - 의존성
        - npm 프로젝트를 운영하는데 필요한 자신 외의 npm 라이브러리
        - peerDependencies
          - 직접적으로 해당 패키지를 import하지는 않지만 호환성으로 인해 필요한 경우.
          - 가령 커스텀 훅을 제공하는 패키지라면
            - react를 만드시 import해야하는 것은 아니지만 *리액트 훅을 제공하는 버전을 설치한 서비스*에서 사용해야만 올바르게 사용할 수 있다. 이 경우 리액트를 peerDependencies로 선언한다.
      - `npm ls [패키지명]`
        - 패키지가 어디에 설치되어 있는지 확인할 수 있는 명령어. ls: list installed packages
      - package.json의 overrides를 사용하면 패키지 내부에 선언된 의존성을 강제로 올릴 수 있다.
    - dependabot이 경고하는 모든 문제를 해결할 필요는 없다. 시급성에 따라 대처하는 게 바람직하다. 그렇지만 관심 가지고 보기!
- 9.3 리액트 애플리케이션 배포하기
  - Netlify, Vercel, DigitalOcean
  - 다들 뭐 쓰시나요?
- 9.4 리액트 애플리케이션 도커라이즈 하기
  - 도커
    - 개념
      - 서비스 운영에 필요한 애플리케이션을 격리해 컨테이너로 만드는데 이용하는 소프트웨어
      - 애플리케이션을 이미지 상태로 준비해두면 이 이미지를 실행할 수 있는 환경 어디에서나 웹 애플리케이션을 배포할 수 있다.
      - 도커는 애플리케이션을 ‘컨테이너’라는 단위로 패키징한다. 도커는 컨테이너를 바탕으로 독립된 환경에서 애플리케이션이 일관되게 실행할 수 있도록 보장해준다.
    - 용어
      - Dockerfile > `빌드` > 도커 이미지 > `실행` > 컨테이너
      - 이미지: 컨테이너를 만드는데 사용되는 템플릿. “환경을 이렇게 구성해줘~“
      - 컨테이너: 이미지를 실행한 상태. 완성된 환경. 이미지가 목표하는 운영체제, 파일 시스템, 각종 자원 및 네트워크가 할당되어 애플리케이션이 실행될 수 있는 독립된 공간.
      - Dockerfile: 이미지 파일을 정의하는 파일. 이 파일을 빌드하면 도커 이미지를 만들 수 있다.
      - 태그: 이미지를 식별할 수 있는 레이블 값
        - ubuntu:latest가 뭔지 드디어 알았다…
          - ubuntu는 이미지명, latest는 태그명
      - 리포지터리: 이미지 저장소.
      - 레지스트리: 리포지터리에 접근할 수 있게 해주는 서비스
    - Dockerfile 작성하기
      - `FROM node:18.12.0-alpine3.16`
        - 이미지를 실행할 베이스 이미지를 설정할 수 있다.
        - 도커 이미지 저장소에서 node:18.12.0, alpine3.16이라는 이미지를 가져와 사용하겠다는 뜻. 이 한 줄 만으로 운영체제 설치 과정 없이 운영체제를 사용할 수 있다.
  - 이미지를 만든다 > 도커 저장소를 생성해 이미지를 업로드 한다 > 클라우드 플랫폼에서 도커 이미지를 실행한다.
