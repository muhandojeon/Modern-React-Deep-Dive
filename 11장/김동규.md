# 11장 Next.js 13과 리액트 18

#스터디-리액트딥다이브

## 11.1 app 디렉터리의 등장

Next.js 12 버전 까지는 페이지 공통 레이아웃을 유지할 수 있는 방법은 \_app이 유일했다. 하지만, 서로 다른 페이지를 유지할만한 여력이 부족하다.

```생각 & 의견
저는 써보지는 않았지만 고차컴포넌트를 이용한 레이아웃등을 많이 사용하는 케이스를 보았는데, App 디렉토리 안쓰시는 분들은 어떻게 사용하고 있으신가요?
```

이런 한계점을 극복하기 위해 나온 것이 app 레이아웃이다.

### 11.1.1 라우팅

기존 `/page` -> `/app` 디렉토리로 변경 되었다. 또한 기존에는 page 디렉토리 내부의 파일명 까지 라우터로 변환이 되었지만 Next.js 13 부터는 폴더명 까지만 라우터로 변경된다.

#### layout.js

이름처럼 기본적인 레이아웃을 구성하는 요소이다. 해당 폴더에 layout이 있다면 그 하위 폴더 및 주소에 모두 영향을 미친다.

> CC-in-JS의 초기화 문제가 있어서 useServerInsertedHTML 같은 훅을 사용해 root layout에 적용해ㅑ 한다.

#### page.js

페이지를 의미한다. app 디렉토리의 예약어이다.

#### error.js

해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트이다. 클라이언트 컴포넌트에서만 작동된다.

#### loading.js

Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용할 수 있다.

#### route.js

파일 내부에 REST API의 get,post 같은 메서드명을 예약어로 선언해두면 해당 요청에 맞게 API를 생성할 수 있다.

## 11.2 리액트 서버 컴포넌트

### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

기존까지의 React 및 Next 구조는 아래와 같은 한계점을 가지고 있다.

- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
- 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
- 자동 코드 분할이 불가능하다.
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
- 추상화에 드는 비용이 증가한다.

서버 사이드, 클라이언트 사이드 렌더링의 각각 장점을 모두 취하고자 하는것이 서버 컴포넌트이다.

### 11.2.2 서버 컴포넌트란?

하나의 언어, 하나의 프레임워크, 하나의 API와 개념을 사용하면서 서버와 클리언트 모두에서 컴포넌트를 렌더링 할 수 있는 기법이다.

- 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없다.

서버 컴포넌트, 클라이언트 컴포넌트, 공용 컴포넌트가 있고 각 제약사항이 있다. 리액트는 기본적으로 모든 것을 공용 컴포넌트로 판단한다. 파일 맨 첫줄에 “use client”라고 작성하면 클라이언트 컴포넌트로 명시적 선언이 가능하다.

### 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이

둘은 대체제가 아닌 상호보완의 개념이다.

### 11.2.4 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다.
2. 받은 요청에 따라 컴포넌트를 JSON으로 직렬화 한다.
3. 브라우저가 리액트 컴포넌틑 트리를 구성한다.

이를 바탕으로 서버 컴포넌트 작동의 특별한 방식은 아래와 같다.

- 클라이언트가 줄 단위로 JSON을 읽고 컴포넌트를 렌더링 할 수 있어 빠르다
- 컴포넌트들이 하나의 번들러 작업에 포함돼 있지 않고필요에 따라 지연해서 받거나를 할 수 있다.
- 결과물이 HTML이 아닌 JSON으로 전달한다.
  > 이로 인해 props로 넘길 때는 반드시 직렬화 가능한 값을 넘겨야한다.

## 11.3 Next.js에서의 리액트 서버 컴포넌트

page.js와 layout.js는 반드시 서버 컴포넌트여야 한다.

### 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

서버에서 데이터를 직접 불러올 수 있게 되었고, 컴포넌트가 비동기적으로 작동하는 것도 가능하다. fetch 요청에 대한 내용을 서버에서 렌더링이 끝날 때 캐싱하며, 클라이언트에서 별도 요청이 없는한 최대한 캐싱하여 사용한다.

### 11.3.2 정적 렌더링과 동적 렌더링

Next.js 13에서는 정적인 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링해두고 캐싱하여 재사용 가능하다. 동적인 라우팅은 요청이 올 때마다 렌더링하도록 변경 되었다.
동적인 주소이지만, 특정 주소에 대해서 캐싱하고 싶은 경우 `generateStaticParams`를 사용하면 된다.

### 11.3.3 캐시와 mutating, 그리고 revalidating

해당 데이터의 유효한 시간을 정해두고 시간이 지나면 다시 데이터를 불러와서 페이지를 렌더링 하는 것 이 가능하다. (revalidate)

### 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기

페이지가 다 완성될때 까지 기다리는 것이 아닌, HTML을 작은 단위로 쪼개어 보내는 스트리밍이 도입 되었다.

## 11.4 웹팩의 대항마, 터보팩의 등장

## 11.5 서버 액션

API를 굳이 생성하지 않더라도 함수 수준에서 서버에서 직접 전근해 데이터를 요청할 수 있는 기능이다.
함수 내부에 “use server” 지시자를 작성해야하고, async 함수를 사용해야 한다.
서버 액션 사용시, “use client”가 선언되어 있는 컴포넌트 내에서 사용할 경우 에러가 발생한다. 서버 액션을 사용하고 싶을 때는 “user server”로 서버 액션만 모여 있는 파일을 별도로 import 해야한다.

## 11.6 그 밖의 변화

프로젝트 전체 라우트에서 쓸 수 있는 미들웨어가 강화 되었고, SEO를 쉽게 작성할 수 있는 기능이 추가 되었다. 정적으로 내부 링크를 분석할 수 있는 기능들도 추가 되었다.

## 11.7 next.js 13 코드 맛보기

pass

## 11.8 정리 및 주의사항

“use client” 지시자들을 통한 서버와 클라이언트 컴포넌트 경계를 명확하게 구분해야 한다. 앞으로 리액트 생태계에 많은 변화를 가져올 것 이다!
