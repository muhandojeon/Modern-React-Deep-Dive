## 11.1 app 디렉터리의 등장

- Next.js 13버전은 Next.js 역사를 통틀어 가장 큰 변화가 있는 릴리스
- \_document: 페이지에서 쓰이는 <html>과 <body>태그를 수정하거나 서버 사이드 렌더링 styled-components 같은 일부 CSS-in-JS를 지원하기 위한 코드를 삽입하는 제한적인 용도로 사용. 오직 서버에서만 작동하므로 onClick 같은 이벤트 핸들러 또는 클라이언트 로직 금지
- \_app: 페이지를 초기화하기 위한 용도로 사용되며 다음과 같은 작업이 가능
  - 페이지 변경 시에 유지하고 싶은 레이아웃
  - 페이지 변경 시 상태 유지
  - componentDidCatch 를 활용한 에러 핸들링
  - 페이지간 추가적인 데이터 삽입
  - global CSS 주입
- 즉 Next.js 12 버전까지 페이지 공통 레이아웃을 유지할 수 있는 방법은 \_app이 유일
- 이러한 한계를 극복하기 위해서 Next.js 13 버전에서 app 레이아웃이 나왔다.

### 11.1.1 라우팅

- 기존에 pages로 정의하던 라우팅 방식이 app 디렉터리로 이동
- 파일명으로 라우팅하는 것이 불가능, 폴더명까지만 주소로 변환
- layout.js
  - app 디렉터리 내부의 폴더에 포함될 수 있는 파일명을 몇 가지로 제한
  - 페이지의 기본 레이아웃을 구성하는 요소
  - 루트 레이아웃에는 기존 \_app, \_document를 대신해 웹페이지를 시작하는데 필요한 공통 코드를 삽입할 수 있다.
- page.js
  - layout을 기반으로 리액트 컴포넌트를 노출
  - page가 받는 props
    - params: 옵셔널 값으로 […id]와 같은 동적 라우트 파라미터를 사용할 경우 해당 파라미터에 값이 들어온다.
    - searchParams: url에서 쿼리파라미터
- error.js
  - 공통 에러 컴포넌트
  - 특정 라우팅별로 서로 다른 에러 UI 렌더링이 가능
  - error.js 가 받는 props
    - error 객체
    - reset 함수
- not-found.js
  - 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지 렌더링
  - 서버 컴포넌트로 구성
- loading.js
  - Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용
  - 클라이언트 컴포넌트로 사용도 가능
- route.js
  - api 디렉터리에서 라우팅 주소를 담당하며 디렉터리의 파일명이 route.js로 통일
  - HTTP method 정의

## 11.2 리액트 서버 컴포넌트

### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 기존 리액트의 모든 컴포넌트는 클라이언트에서 작동하며 브라우저에서 자바스크립트 코드 처리가 이뤄진다. : 클라이언트 사이드 렌더링
  - 코드 다운로드 → 리액트 컴포넌트 트리 생성 → DOM에 렌더링
- 서버 사이드 렌더링?
  - 미리 서버에서 DOM을 만들어 오고 → 이 DOM을 기준으로 하이드레이션 진행
- 서버 사이드 렌더링의 한계
  - 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
  - 게시판 등 사용자가 작성한 HTML에 위험한 태그를 제거하기 위해 사용되는 sanitize-html 라이브러리
    - 63.3kb에 달하는 용량
    - 클라이언트 사이드에서 렌더링하면 사용자 기기의 부담이 됨
  - 백엔드 리소스에 대한 직접 접근이 불가
    - REST API를 사용하게 되면 백엔드에서 항상 클라이언트에서 데이터에 접근하기 위한 방법을 마련해야 한다는 단점
    - 클라이언트에서 직접 import db로 데이터베이스에 직접 액세스하거나 파일시스템에 접근하는게 편하다.
  - 자동 코드 분할이 불가능
    - 거대한 코드 번들 대신 코드를 여러 작은 단위로 나누어 필요할 때만 동적으로 지연 로딩
    - 일반적으로 리액트에서는 lazy를 사용해서 구현
  - 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어려움
  - 추상화에 드는 비용이 증가

### 11.2.2 서버 컴포넌트란?

- 하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법
- 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없음
- 서버 컴포넌트
  - 요청이 오면 그 순간 서버에서 딱 한번 실행될 뿐이므로 상태를 가질 수 없다. (useState, useReducer 사용 불가)
  - 렌더링 생명주기도 없다. (useEffect, useLayoutEffect 사용 불가)
  - window.document에 접근 불가
  - 서버에만 있는 데이터를 async/await 로 접근할 수 있음
  - div span p 같은 요소를 렌더링하거나 클라이언트 컴포넌트를 렌더링할 수 있다.
- 클라이언트 컴포넌트
  - 서버 컴포넌트, 서버 전용 훅, 유틸리티를 불러올 수 없다.
  - 서버 → 클라이언트 → 서버 컴포넌트의 구조는 가능

### 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이

- 서버 컴포넌트와 서버 사이드 렌더링은 완전히 다른 개념
- 서버 사이드 렌더링
  - 응답받은 페이지 전체를 HTML로 렌더링하는 과정을 서버에서 수행한 후 그 결과를 클라이언트에 내려준다.
  - 이 후 클라이언트에서 하이드레이션 과정을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 등의 작업 수행
  - 초기에 인터랙션은 불가하지만 정적인 HTML을 빠르게 내려주는데 초점
- 서버 사이드 렌더링과 서버 컴포넌트를 모두 채택하는 것도 가능
- 둘은 대체재가 아닌 상호보완하는 개념

### 11.2.4 서버 컴포넌트는 어떻게 작동하는가?

- 서버가 렌더링 요청을 받는다. 루트 컴포넌트는 항상 서버 컴포넌트다.
- 컴포넌트를 JSON으로 직렬화한다.
- 브라우저가 리액트 컴포넌트 트리를 구성. 최종적으로 이 트리를 렌더링해 브라우저의 DOM에 커밋
- 서버 컴포넌트 특별한 점
  - 스트리밍 형태로 보냄으로써 클라이언트가 줄 단위로 JSON을 읽고 컴포넌트를 렌더링할 수 있어서 빠르게 결과물을 보여줄 수 있음
  - 각 컴포넌트별로 번들링이 별개로 되어 필요에 따라 지연해서 받는 작업이 가능
  - 서버 사이드 렌더링과는 다르게 결과물이 HTML이 아닌 JSON형태로 보내짐. 이유는 단순히 HTML을 그리는 작업 이상의 일을 필요로 하기 때문.

## 11.3 Next.js에서의 리액트 서버 컴포넌트

### 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

- 모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이뤄진다.

### 11.3.2 정적 렌더링과 동적 렌더링

- 정적 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해서 재사용할 수 있게
- 동적 라우팅에 대해서는 서버에 매번 요청이 올 때 마다 컴포넌트를 렌더링하도록 변경
- 동적이지만 특정 주소에 대해서 캐싱하고 싶은 경우에는 generateStaticParams를 사용 (구. getStaticPaths)

### 11.3.3 캐시와 mutating, 그리고 revalidating

- fetch의 기본 작동을 재정의해 해당 데이터의 유효한 시간을 정해두고 이 시간이 지나면 다시 데이터를 불러와서 페이지를 렌더링 하는 방법? → revalidate 라는 변수 선언

```jsx
export const revalidate = 60;
```

- 이렇게 선언해두면 하위에 있는 모든 라우팅에서는 페이지를 60초 간격으로 갱신해 새로 렌더링
- 캐시를 전체적으로 무효화하고 싶을 때는 `router.refresh()` 사용

### 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기

- 과거의 서버 사이드 렌더링은 페이지가 다 불러와질 때까지 사용자는 빈 화면을 보게 된다.
- 스트리밍을 활용하면 모든 데이터가 로드될 때까지 기다리지 않더라도 먼저 데이터가 로드되는 컴포넌트를 빠르게 보여주는 방법이 가능하다.
- 핵심 웹 지표인 FCP 개선에 큰 도움을 준다.
- 스트리밍을 활용할 수 있는 방법
  - 경로에 loading.tsx 배치
  - Suspense 배치

## 11.4 웹팩의 대항마, 터보팩의 등장(beta)

- SWC는 많은 프로젝트에서 바벨을 대신해 사용되고 있다.
- Next.js 13 에서는 터보팩이 출시됐다.
- 터보팩은 웹팩 대비 최대 700배, vite 대비 최대 10배 빠르다.
- 러스트를 기반으로 작성
- 개발 모드에서만 제한적으로 사용이 가능

## 11.5 서버 액션(alpha)

- API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행할 수 있는 기능
- 이 서버 액션을 활성화하려면 next.config.js에서 실험 기능 활성화 필요
- ‘use server’ 선언하고 함수는 async로 호출

### 11.5.1 form의 action

- form action에 달아주는 함수를 서버 액션으로 만들어주게 되면 해당 이벤트를 발생시키는 것은 클라이언트지만 실제로 함수 자체가 수행되는 것은 서버가 된다.
- 클라이언트 번들링 결과물에는 해당 함수가 포함되지 않고 서버에서만 실행됨
- 폼과 실제 노출하는 데이터가 연동되어 있을 때 더욱 효과적으로 쓸 수 있다.
- 데이터 추가 및 수정 요청을 좀 더 자연스럽게 수행할 수 있고, 캐시를 효과적으로 초기화할 수 있다.

### 11.5.2 input의 submit과 image의 formAction

- form action과 동일하게 서버 액션을 추가할 수 있다.

### 11.5.3 startTransition과의 연동

- useTransition에서 제공하는 startTransition에서도 서버 액션을 활용할 수 있다.
- page 단위의 loading.jsx를 사용하지 않아도 된다는 장점 ⇒ isPending을 활용해 startTransition으로 서버 액션이 실행됐을 때, 해당 버튼을 숨기고 로딩 버튼을 노출해서 페이지 단위가 아닌 컴포넌트 단위의 로딩 처리가 가능

### 11.5.4 server mutation이 없는 작업

### 11.5.5 서버 액션 사용 시 주의할 점

- 클라이언트 컴포넌트 내에 정의될 수 없다.
- 서버 액션을 클라이언트 컴포넌트에 넘길 수 있다. (서버 컴포넌트에서 클라이언트 컴포넌트를 불러올 수 있는 것과 동일한 원리)

## 11.6 그 밖의 변화

- SEO를 쉽게 작성할 수 있는 기능이 추가
- 라우트 미들웨어 강화
- 정적으로 내부 링크를 분석할 수 있는 기능

## 11.7 Next.js 13 코드 맛보기

### 11.7.1 getServerSideProps와 비슷한 서버 사이드 렌더링 구현해 보기

### 11.7.2 getStaticProps와 비슷한 정적인 페이지 렌더링 구현해 보기

### 11.7.3 로딩, 스트리밍, 서스펜스

- loading과 Suspense 모두 동일한 방식으로 작동하며 Suspense가 조금 더 개발자가 원하는 형태로 쪼개서 보여줄 수 있다.
