# 리액트 훅 깊게 살펴보기

## useState

* 실제 리액트 코드에서는 useReducer를 이용해 구현돼 있다
* 함수의 실행이 끝났음에도 선언된 환경을 기억하기 위해 클로저를 사용한다

* 애플리케이션 전체의 state들을 배열로 초기화

<!-- 오혜성이 추가한 내용 -->

```
리액트는 훅들을 배열로 관리하고 있다
라는 제목의 아티클도 공유드립니당
https://pozafly.github.io/react/react-is-managing-hooks-as-an-array/
```

* 실제 리액트의 훅에 대한 구현체는 공개되어 있지 않다
  + `__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED`

### 게으른 초기화

useState에 변수 대신 함수를 넘기는 것을 게으른 초기화(lazy initialization)라고 한다

* 공식 문서에서 게으른 초기화는 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하라고 돼 있다
  + 게으른 초기화 함수는 오로지 state가 처음 만들어질 때만 사용되기 때문

```tsx
useState(Number.parseInt(localStoraget.getItem('foo')));
```

* 위와 같은 코드는 최초 렌더링과 초깃값이 더 필요 없는 리렌더링 시에도 동일하게 계속 해당 값에 접근해서 낭비가 발생한다
  + 함수 형태로 인수로 넘겨주는 편이 훨씬 경제적일 것이다

<!-- 오혜성이 추가한 내용 -->

```
localStorage, sessionStorage에 대한 접근은 무겁다?
```

## useEffect

* 생명주기 메서드를 대체하기 위해 만들어진 훅이 아니다

정확하게 정의를 내리자면

 `useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘`

* 함수형 컴포넌트는 렌더링 시마다 고유의 state와 props 값을 갖고 있다
* useEffect는 자바스크립트의 proxy, 데이터 바인딩, 옵저버 같은 특별한 기능을 통해 값의 변화를 관찰하는 것이 아니고 렌더링할 때마다 의존성에 있는 값을 보면서 이전과 다른 게 하나라도 있으면 부수 효과를 실행하는 평범한 함수라 볼 수 있다.

### 클린업 함수

클린업 함수는 비록 새로운 값을 기반으로 렌더링 뒤에 실행되지만

이 변경된 값을 읽는 것이 아니라 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행된다는 것이다.

* 클린업 함수는 생명주기 메서드의 언마운트 개념과는 차이가 있다
  + 언마운트는 특정 컴포넌트가 DOM에서 사라진다는 것을 의미
  + 클린업 함수는 함수형 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 말 그대로 이전 상태를 청소해 주는 개념으로 보는 것이 옳다

### 의존성 배열

```tsx
function Component() {
  console.log('foo')
}

function Component() {
  useEffect(() => {
    console.log('bar')
  })
}
```

위 코드의 차이점은 다음과 같다

* useEffect는 클라이언트 사이드에서의 실행을 보장
* useEffect 내부는 컴포넌트의 렌더링이 완료된 이후에 실행된다.
  + 직접 실행은 컴포넌트가 렌더링되는 도중에 실행된다

### 구현

* Object.is를 기반으로 얕은 비교를 수행

### 주의 사항

* 의존성 배열에 빈 배열을 넘기기 전에 정말로 부수 효과가 컴포넌트의 상태와 별개로 작동해야만 하는지, 여기서 호출하는 게 최선인지 한 번 더 검토해 봐야 한다

* `useEffect(function logUser() {}, [])`
  + 함수명을 부여해 useEffect의 목적을 명확히 하고 책임을 최소한으로 좁힌다는 점에서 유용하다

* 가능한 한 useEffect는 간결하고 가볍게 유지하는 것이 좋다

<!-- 오혜성이 추가한 내용 -->

```
관심사에 따라 사용자 정의 훅을 만들어 사용하는 것을 좋아함
- 이를 통해 컴포넌트 내부에서는 UI에 대한 로직에만 집중할 수 있달까나
```

### useEffect 콜백 인수로 비동기 함수를 바로 넣을 수 없는 이유

* 기술적인 문제가 있어서가 아니다
* useEffect에서 비동기로 함수를 호출할 경우 경쟁 상태(race condition)가 발생할 수 있기 때문
  + 즉 비동기 useEffect는 state의 경쟁 상태를 야기할 수 있고
  + 클린업 함수의 실행 순서도 보장할 수 없기 때문에
  + 개발자의 편의성을 위해 useEffect에서 비동기 함수를 인수로 받지 않는다고 볼 수 있다

* 비동기 함수가 내부에 존재하게 하여, abortController를 통해 이전 요청을 취소하는 것이 좋다

## useMemo

비용이 큰 연산에 대한 결과를 메모이제이션하고 저장된 값을 반환하는 훅

* useMemo를 사용해 컴포넌트 메모이제이션도 가능
  + 물론 React.memo를 쓰는 것이 더 현명

## useCallback

useMemo가 값을 기억한다면, useCallback은 인수로 넘겨받은 콜백 자체를 기억한다

* useCallback에 기명 함수를 넘겨주어 크롬 메모리 탭에서 디버깅을 용이하게 할 수 있다
* useCallback은 useMemo를 사용해 구현할 수 있다 (Preact의 경우 이렇게 구현되어 있다)
  + 둘의 유일한 차이는 대상이 변수냐 함수냐일 뿐이다
  + 자바스크립트에서는 함수 또한 값으로 표현될 수 있으므로 이러한 코드는 매우 자연스럽다고 볼 수 있다
  + 다만 useMemo로 useCallback을 구현하는 경우 코드가 불필요하게 길어지고 혼동을 야기할 수 있으므로 리액트에서 별도로 제공하는 것으로 추측해 볼 수 있다

## useRef

useState와 동일하게 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장

* 함수 외부에 값을 선언해서 관리하는 것도 동일하지 않을까?
  

```tsx
  let value = 0
  function Component() {
    return <>{value}</>
  }
  ```

  + 컴포넌트가 실행되어 렌더링되지 않았음에도 value라는 값이 기본적으로 존재하게 되어 메모리에 불필요한 값을 갖게 한다
  + 컴포넌트가 여러 번 생성된다면 각 컴포넌트가 가리키는 값이 모두 동일하다
    - 컴포넌트가 초기화되는 지점이 다르더라도 하나의 값을 봐야 하는 경우라면 유효할 수도 있지만
    - 대부분의 경우에는 컴포넌트 하나당 하나의 값을 필요로 하는 것이 일반적

* useRef를 사용해 usePrevious 구현

* preact에서는 useMemo를 이용해 useRef가 구현되어 있다
  + 자바스크립트의 특징, 객체의 값을 변경해도 객체를 가리키는 주소가 변경되지 않는다는 것을 떠올리면 useMemo로 useRef를 구현할 수 있다

## useContext

* props drilling을 극복하기 위해 등장한 개념
  + 선언한 하위 컴포넌트 모두에서 자유롭게 원하는 값을 사용할 수 있다

* 다수의 Provider와 useContext를 사용할 때, 특히 타입스크립트를 사용하고 있다면 위와 같이 별도 함수로 감싸서 사용하는 것이 좋다.
  + 타입 추론에 유용하고
  + 프로바이더가 없는 경우에도 에러를 던질 수 있다

### 주의할 점

* useContext가 있는 컴포넌트는 그 순간부터 눈으로 직접 보이지 않는 Provider와 의존성을 갖게 된다

* 일부 리액트 개발자들이 Context와 useContext를 상태 관리를 위한 리액트 API라고 오해하고 있다
  + 엄밀히 따지면 Context는 상태를 주입해 주는 API다
  + 상태 관리 라이브러리가 되기 위해서는 최소한 다음 두 조건을 만족해야 한다
    - 어떠한 상태를 기반으로 다른 상태를 만들어 낼 수 있어야 한다
    - 필요에 따라 이러한 상태 변화를 최적화할 수 있어야 한다
    - 그러나 Context는 둘 중 어느 것도 하지 못한다. 단순히 props 값을 하위로 전달해 줄 뿐

* 상태가 변화하면 프로바이더 트리 전체가 리렌더링된다
  + 물론 React.memo를 사용해 최적화할 수 있다

## useReducer

복잡한 상태값을 미리 정의해 놓은 시나리오에 따라 관리할 수 있다

* 사용하는 모습이 언뜻 복잡해 보일 수 있지만 목적은 간단하다
  + 복잡한 형태의 state를 사전에 정의된 dispatcher로만 수정할 수 있게 만들어 줌으로써
    - state 값을 변경하는 시나리오를 제한적으로 두고 이에 대한 변경을 빠르게 확인할 수 있게끔 하는 것이 useReducer의 목적이다

* Preact의 useState 코드는 useReducer로 구현되어 있다
* 필요에 맞게 useReducer나 useState를 취사선택해 사용하면 된다

## useImperativeHandle

### forwardRef

* 다른 props 이름으로 동일한 작업을 할 수 있지만
  + ref를 전달하는 데 있어서 일관성을 제공하기 위해 탄생되었다

useImperativeHandle은 부모에게서 넘겨받은 ref를 원하는 대로 수정할 수 있는 훅이다

```tsx
const Input = forwardRef((props, ref) => {
  useImperativeHandle(
    ref, 
    () => ({alert: () => alert('foo')}),
    [props.value]
  )
})
```

## useLayoutEffect

useEffect와 동일하나, 모든 DOM의 변경 후에 동기적으로 발생한다

```
1. 리액트가 DOM을 업데이트
2. useLayoutEffect 실행
3. 브라우저에 변경 사항을 반영
4. useEffect 실행
```

* useLayoutEffect가 브라우저에 변경 사항이 반영되기 전에 실행
* useEffect는 브라우저에 변경 사항이 반영된 이후에 실행

* DOM은 계산되었지만 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때 사용하는 것이 좋다

<!-- 오혜성이 추가한 내용 -->

```
scroll 복구 시 사용하면 좋을 거 같아용
저는 next experimental spec이 동작하지 않았음..
```

## useDebugValue

* 디버깅하고 싶은 정보를 이 훅에다 사용하면 리액트 개발자 도구에서 볼 수 있다
* useDebugValue를 사용할 때는 오직 다른 훅 내부에서만 실행할 수 있음
  + 컴포넌트 레벨에서 실행한다면 작동하지 않음

## 훅의 규칙

리액트 훅은 파이버 객체의 링크드 리스트의 호출 순서에 따라 저장된다
* 각 훅이 파이버 객체 내에서 순서에 의존해 state나 effect의 결과에 대한 값을 저장하고 있기 때문
* 고정된 순서에 의존해 훅과 관련된 정보를 저장함으로써 이전 값에 대한 비교와 실행이 가능해짐

## 사용자 정의 훅과 고차 컴포넌트

단순히 컴포넌트 전반에 걸쳐 동일한 로직으로 값을 제공하거나, 동작을 취하게 하고 싶다면 `사용자 정의 훅` 을 사용하는 것이 좋다

함수형 컴포넌트의 반환값, 즉 렌더링의 결과물에도 영향을 미치는 공통 로직이라면 `고차 컴포넌트` 를 사용하자

* 사용자 정의 훅 라이브러리
  + use-hooks, react-use, ahooks

* 고차 함수의 사전적 정의 `함수를 인수로 받거나 결과로 반환하는 함수`

* 인증 처리는 서버나 NGINX와 같이 자바스크립트 이전 단계에서 처리하는 편이 효율적이다

<!-- 오혜성이 추가한 내용 -->

```
여러분들은 인증 처리를 어떻게 하고 있는지 궁금하네용
예를 들어 사용자 인증 정보 (토큰)을 브라우저 스토리지에 저장해두고 있다면
이를 서버나 미들웨어 단에서 할 수 있는 방법...?
```

* 고차 컴포넌트가 with으로 시작하는 것은 일종의 관습
