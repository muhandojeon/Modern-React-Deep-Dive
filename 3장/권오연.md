## 3.1 리액트의 모든 훅 파헤치기

### 3.1.1 useState

- 함수형 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해 주는 훅
- 193p 코드 참고
- useState의 내부 구조는 클로저를 활용해서 state의 값을 유지하고 사용한다.
- 게으른 초기화
  - useState의 초깃값에 변수 대신 함수를 넘기는 것
  - 이 방법은 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용할 것
    - 예시) localStorage, sessionStorage에 접근 / map, filter, find 같은 배열에 대한 접근 등
  - 여기서 넘겨지는 함수는 오로지 state가 처음 만들어질 때만 사용되고 이후에 리렌더링이 될 때는 무시되기 때문

### 3.1.2 useEffect

- 클린업 함수
  - useEffect 내에서 반환되는 함수
  - 이전 state를 참조해 실행된다. = 말 그대로 이전 상태를 청소해 주는 개념
  - useEffect에 이벤트를 추가하면 클린업 함수에서 삭제가 필요함 (무한 이벤트 추가를 방지하기 위해서)
- 의존성 배열
  - 빈 배열 - 최초 렌더링 시에만 수행
  - undefined - 매 렌더링 시에 수행
- useEffect 효과
  - 매 렌더링시 마다 수행되는 것은 useEffect를 쓰나 안쓰나 동일하지만 클라이언트 사이드에서 실행되는 것을 보장해주는 효과가 있다.
  - useEffect를 쓰지 않으면 컴포넌트에 렌더링되는 도중에 실행되지만, useEffect를 사용하면 컴포넌트의 렌더링이 완료된 이후에 실행된다. → 즉, 렌더링을 방해해 성능에 악영향을 미칠 수 있다.

### 3.1.7 useReducer

- useState의 심화 버전
- 반환값은 useState와 동일하게 길이가 2인 배열
- 인수는 2~3개를 필요로 함
  - reducer: useReducer의 첫번째 action을 정의
  - initialState: useReducer의 초깃값
  - init: useState의 인수로 함수를 넘겨줄때 처럼 초깃값을 지연해서 생성시키고 싶을 때 사용하는 함수 (게으른 초기화)
- 목적: state 값을 변경하는 시나리오를 제한적으로 두고 이에 대한 변경을 빠르게 확인할 수 있게끔 하는 것

### 3.1.8 useImperativeHandle

- forwardRef
  - ref를 상위 컴포넌트에서 하위 컴포넌트로 전달하고 싶은 경우? ref라는 변수를 그대로 prop으로 넘기면 에러가 뜬다. 이름을 바꾸면 에러는 뜨지 않음. 그런데 forwardRef를 사용하면 ref라는 변수로 prop을 넘겨도 에러가 뜨지 않는다.
- useImperativeHandler
  - 부모에게서 넘겨받은 ref를 원하는대로 수정할 수 있는 훅
  - alert 등 추가적인 동작을 정의할 수 있다.

### 3.1.9 useLayoutEffect

- 이 함수의 시그니처는 useEffect와 동일하나 모든 DOM의 변경 후에 동기적으로 발생

1. 리액트가 DOM을 업데이트
2. useLayoutEffect 를 실행
3. 브라우저에 변경 사항을 반영
4. useEffect 를 실행

- DOM은 계산됐지만 이것이 화면에 반영되기 전에 하고 싶은 작업이 있을 때 활용
- 특정 요소에 따라 DOM 요소를 기반으로 한 애니메이션, 스크롤 위치를 제어하는 등

### 3.1.10 useDebugValue

- 개발 단계에서 사용하는 훅 (프로덕션 X)
- 디버깅하고 싶은 정보를 이 훅에 사용하면 리액트 개발자 도구에서 볼 수 있다.
- 사용자 정의 훅 내부의 내용에 대한 정보를 남길 수 있는 훅, 두 번째 인수로 함수를 전달하면 인수의 값이 변경됐을 때 호출되어 값을 노출

### 3.1.11 훅의 규칙

- react-hook/rules-of-hooks
- 최상위에서만 훅을 호출해야 한다.
- 반복문이나 조건문, 중첩된 함수 내에서 훅을 실행할 수 없다.

→ 컴포넌트가 렌더링 될 때마다 항상 동일한 순서로 훅이 호출되는 것을 보장할 수 있다.

- 함수형 컴포넌트, 사용자 정의 훅 내부에서만 훅을 호출할 수 있다.
- 그래서 훅은 항상 실행 순서를 보장받을 수 있는 컴포넌트 최상단에 선언되어야 한다.

## 3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

### 3.2.1 사용자 정의 훅

- 고차 컴포넌트은 어디서나 사용 가능
- 사용자 정의 훅은 리액트에서만 사용 가능
- 규칙: 반드시 use로 시작하는 함수를 만들어야 한다.

### 3.2.2 고차 컴포넌트

- 컴포넌트 자체의 로직을 재사용하기 위한 방법
- React.memo
  - 대표적인 고차 컴포넌트 API
  - 렌더링하기 앞서 props를 비교해 이전과 props가 같다면 렌더링 자체를 생략하고 이전에 기억해 둔 memoization 컴포넌트를 반환
  - 컴포넌트에 memo()로 감싸는 방식으로 사용
- 고차 함수 만들어보기
  - 고차 함수를 활용하면 함수를 인수로 받거나 새로운 함수를 반환해 완전히 새로운 결과를 만들어낼 수 있다.
- 고차 컴포넌트 만들어 보기
  - with 로 시작해야 한다.
  - 부수 효과를 최소화
    - props를 임의로 수정, 추가, 삭제 하면 안된다.
    - 계속 컴포넌트를 감쌀 경우 복잡성이 커진다는 단점이 있다.
    - 최소한으로 사용하는 것이 좋다.

### 3.2.3 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

- 사용자 정의 훅이 필요한 경우
  - 훅으로만 공통 로직을 격리할 수 있다면 사용자 정의 훅을 사용하는 것이 좋다.
  -
