# 4장 설벌 사이드 렌더링

Next.js 같은 프레임워크를 사용해 프로젝트를 만드는 것이 큰 인기를 얻고 있다. 왜 인지 알아보자!

## 4.1 서버 사이드 렌더링이란?

SPA 보다 신경써야 하는 점이 훨씬 많다.

```개인의견
Vercel에서 SSR 걷어낸 SPA용 프레임워크 한개 만들어주면 인기 많을 것 같다 라는 생각을 많이 해봤습니다..
이런 생각해보신 적 있으신가요? ㅋㅋㅋ
```

### 4.1.1 싱글 페이지 애플리케이션의 세상

#### 싱글 페이지 어플리케이션이란?

- 렌더링과 라우팅에 필요한 대부분의 기능을 브라우저 자바스크립트에 의존하는 방식
- 페이지 전환을 위한 모든 작업이 브라우저의 [history.pushState](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) 와 [history.replaceState](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState)로 사용한다.

```추가자료
history는 페이지 이동없이 브라우저 주소만 바꿔주는 것 이라고 보면 되고, 실제 브라우저의 뒤로가기 버튼 등을 활성화 시킨다고 합니다.
지금은 많이 안쓰지만 history 방식과 함께 많이 언급되었던 hash(https://developer.mozilla.org/en-US/docs/Web/API/Location/hash)방식도 있습니다.
```

#### 전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교

- 전통적인 방식은 사용자 입장에서 페이지가 처음부터 다시 만들어지는 것처럼 보인다
  - HTML을 다시 요청받아 그리는 작업이 있기 때문에!
- 싱글 페이지 방식은 최초에 모든 리소스를 다운받고, 자바스크립트로 모두 처리
  - 대표적으로 GMail이 싱글페이지로 만들었다.

#### 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

JavaScript의 발전과 JAM스택 등장까지의 흐름

- 자바스크립트를 통한 보조적인 역할
- Common.js AMD 같은 자바스크립트 모듈화 기술 발달
- AngularJS 같은 MVx 프레임워크 구현화
- React, Vue 등의 프레임워크 등장
- JAM 스택의 등장

#### 새로운 패러다임의 웹서비스를 향한 요구

- 모바일 기기의 성능은 늘어나지만, 모바일에서의 웹페이지 로딩은 20초 가까이 될 정도로 오래 걸린다.
- 웹 환경이 크게 개선되었어도 실제 사용자들이 느끼는 로딩속도는 5년 전이나 지금이나 차이가 크게 없다.

### 4.1.2 서버 사이드 렌더링이란?

웹 페이지의 렌더링 책임을 브라우저에 두면, SPA 서버에 두면 SSR이 된다.

#### 서버 사이드 렌더링의 장점

- 최초 페이지 진입이 "비교적" 빠르다
- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다
- 누적 레이아웃 이동이 적다
- 사용자의 디바이스 성능에 비교적 자유롭다
- 보안에 좀 더 안전하다

#### 서버 사이드 렌더링의 단점

- 소스코드를 작성할 때 항상 서버를 고려해야한다.
- 적절한 서버가 구축돼 있어야 한다.
- 서비스 지연에 따른 문제

### 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

은탄환은 없다!

#### 서버 사이드 렌더링 역시 만능은 아니다

잘못된 설계는 성능 개선을 얻지 못하고, 관리 포인트가 두군개로 나뉘어 역효과를 발생시킬 수 있다. 웹 페이지의 목적에 따라 어떤 기술을 사용할 지 선택해야한다.

#### 싱글 페이지 애플리케이션과 서버 사이드 렌더링 애플리케이션

- 가장 뛰어난 싱글 페이지 애플리케이션은 가장 뛰어난 멀티 페이지 애플리케이션보다 낫다.
- 평균적인 싱글 페이지 애플리케이션은 평균적인 멀티 페이지 애플리케이션 보다 느리다.

#### 현대의 서버 사이드 렌더링

- 과거 LAMP 스택의 장점과 SPA의 장점 두가지를 취하고 있다.
  - 최초 진입 시 서버에서 HTML을 받고
  - 이후, SPA처럼 작동 (라우터 등..)

```개인의견
개인적으로 SSR은 실제 유저가 사용하는 서비스 거나 SEO가 필요한 서비스에 사용하자는 원칙을 가지고 있습니다. 그외 나머지 프로젝트에서는 SPA를 쓰자 라는 생각입니다. 주로 백오피스 같은 프로젝트들 SPA를 사용하는 것 같아요!(서버에 들어가는 비용문제도 고려)
```

## 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

리액트는 리액트 애플리케이션을 서버에서 렌더링 할 수 있는 API를 제공한다.

### 4.2.1 renderToString

- 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수. **자바스크립트 코드는 포함하지 않는다.**
- 리액트의 서버 사이드 렌더링은 단순히 최초의 HTML을 빠르게 그려주는것이 목적
- `div#root` 에 존재하는 속성인 `data-reactroot`는 hydrate함수에서 루트를 식별하는 기준점이 된다.

### 4.2.2 renderToStaticMarkup

- renderToString과의 차이점은 `data-reactroot`같은 리액트만의 추가적인 DOM 속성을 만들지 않는다.

  - HTML의 크기를 약간이라도 줄일 수 있다.

- hydrate를 수행하는 경우, 서버와 클라이언트 내용이 맞지 않는다는 에러를 뿜는다.
  - 이벤트 리스너가 필요 없는 순수한 HTML을 만들 때 사용된다

### 4.2.3 renderToNodeStream

- renderToString과의 차이점은 아래와 같다
  - 브라우저에서 사용하는것이 불가능하다
  - ReadableStream 파일 타입으로 리턴된다.
    - Node.js 환경에서만 사용 가능함으로 브라우저가 원하는 결과물을 얻기 위해는 다른 처리가 필요하다
- 널리 알려진 리액트 서버 사이드 렌더링 프레임워크는 모두 renderToNodeStream을 채택하고 있다.

### 4.2.4 renderToStaticNodeStream

- renderToNodeStream과 다르게 리액트 속성이 제공되지 않는다.

### 4.2.5 hydrate

- 앞선 기능들은 HTML으로 보여주는건 가능하지만 인터랙션이 불가능. hydrate는 여기에 이벤트 핸들러를 붙여 완전한 웹 페이지를 만드는 역할을 한다.
- 리액트 속성이 없는 경우 불일치 에러를 반환하고, 렌더링한 기준으로 웹페이지를 그린다.
  - 결국, 서버와 클라이언트 두번 렌더링 되는 것이고 SSR의 장점을 버리는 것 이기 때문에 고쳐야한다!
- 불가피하게 불일치가 발생하는 요소의 경우 `suppressHydrationWarning`을 추가하여 경고를 볼 수 있다.

### 4.2.7 정리

- 사용자에게 더 빠른 웹페이지를 제공하는 것에는 이점이 있다.
- 하지만 많이 복잡하다...
- 리액트 API 작동방식을 아는 것이 프레임워크를 배우는 것보다 프레임워크를 이해하는데 도움 된다.
