# 2장 리액트 핵심 요소 깊게 살펴보기

## 2.1 JSX란?
JSX란 속성을 가진 트리 구조를 표현하기 위한 XML과 비슷한 문법이다.

정말 신기하고 처음 보는 JSX 문법들을 본 것 같았다.

최근 회사에서 swiper 라이브러리를 사용하며 마이그레이션 문서를 봤었는데 조금 신기했었다.
https://swiperjs.com/migration-guide-v10

```typescript jsx
<swiper-container>
</swiper-container>
```

요런 것도 되는구나,, 했었는데 책을 보니 별에 별 문법들이 나와서 신기했습니다.

### JSX Children
트리 구조 중 자식 요소를 표현하기 위한 문법이다.

태그를 열고 닫는 '<', '>' 혹은 중괄호를 표현하기 위해선 후처리가 필요하다.


### JSX Strings
복사와 붙여넣기를 쉽게 할 수 있게끔 설계한 구조라고 하니 참 페이스북 개발자들은 대단하다.

`esacpe` 의 경우도 보여줄 때 간단하게 처리할 수 있다.
```typescript jsx
    <>\</>
```

킹바스크립트나 여타 다른 언어에서는 보여주기 위해선 '\\' 이런 식으로 처리해야 한다.


## 2.1.2 JSX 예제

아래의 문법은 compound 형태로 설계할 때 자주 사용하는 패턴인데

```typescript jsx
function A(){
    return <A.B></A.B>
}
```

```typescript jsx
function A(){
    return <A.B.C></A.B.C>
}
```

이게 유효한 것인 줄은 몰랐다.

## 2.1.3 JSX는 어떻게 자바스크립에서 변환될까?

어쨌든 JSX 문법은 브라우저에서 실행되려면 자바스크립트로 변환되어야 한다.

이는 babel이라는 트랜스파일러를 통해 이루어진다.
Next.js를 사용한다면 SWC라는 컴파일러를 사용한다고 알고 있다.

> 궁금한 점
> 
> p.127의 예시 코드가 괜찮을까?,, 코드리뷰 빠꾸 먹을 것 같은데 그냥 as를 통해 다형성을 표현하는 것이 좋지 않을까요?,, (잘모름)


## 2.2 가상 DOM과 리액트 파이버

### 2.2.2 가상 DOM의 탄생 배경

가상 DOM을 통해 화면에 그려지는 것들의 상태 관리나 렌더링에 관한 부분은 추상화하여, 개발자는 결과물에만 집중할 수 있게끔 해준다.

사실상 개발자가 담당해야할 부분을 단순히 뷰를 그리는 것으로만 남겨두었다.

### 2.2.3 가상 DOM을 위한 아키텍쳐, 리액트 파이버

- 리액트 파이버란 리액트에서 관리하는 자바스크립트 객체다.
- 리액트 파이버는 컴포넌트와 1:1로 매칭된다.
- 재조정이란 가상 DOM과 실제 DOM을 비교하는 알고리즘이다.

지금까지 알고 있던 것도 이전의 스택으로 구현된 재조정 알고리즘으로 동기식으로 작동하는 것으로만 알고 있었다.

다만 리액트 파이버는 비동기식으로 작동한다.



## 2.3 클래스형 컴포넌트와 함수형 컴포넌트

여러분들은 클래스형 컴포넌트를 사용한 경험이나, 유지보수를 해야하는 상황이 있으실까요?!

저는 별로 좋아하질 않아서 시원하게 넘기겠습니다.

면접용 단점 나열

- 데이터의 흐름을 추적하기 힘들다.
- 내부 로직을 재활용하기 힘들다.
- 기능이 많아질수록 코드가 복잡해진다. (함수 몇개 넣으면 일단 100줄)
- 코드 크기를 최적화하기 힘들다. (minify, tree shaking)


## 2.3.2 갓수형 컴포넌트

함수형 컴포넌트 this 바인딩, mutable과 같은 문제를 해결할 수 있다.

더불어 생명주기도 메서드도 없기에 이해하기 편하다.

> 나중에 나오겠지만 여러분들은 useEffect를 좋아하시나요?!
> 
> 저는 별로 안 좋아합니다,,!


## 2.4 렌더링은 어떻게 일어나는가?

### 2.4.2 리액트의 렌더링이 일어나는 이유

렌더링이 일어나는 시나리오는 아래와 같다.

- 최초 렌더링
- 리렌더링
  - useState가 반환하는 배열의 두번째 인자인 setState를 실행하는 경우
  - useReducer가 반환하는 배열의 두번째 인자인 dispatch를 실행하는 경우
  - 컴포넌트의 key props가 변경되는 경우

### 2.4.3 리액트의 렌더링 프로세스
- 업데이트가 필요하다고 지정되어 있는 모든 컴포넌트를 찾는다.
- render 함수나 함수 자체를 호출하여 결과물을 저장한다.

> 이는 jsx 문법으로 작성된 코드를 자바스크립트 코드로 컴파일 하기에 가능하다.
 
렌더링 프로세스가 진행되며 각 컴포넌트의 결과물을 수집한 다음, 가상 DOM과 비교해 실제 반영하기 위한 변경 사항을 수집한다.

이를 재조정이라고 한다.

### 2.4.4 렌더와 커밋

리액트의 렌더링 프로세스는 렌더 단계와 커밋 단계로 분리되어 진행된다.

#### 렌더 단계
컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업이다.

여기서 비교하는 부분은 크게 type, props, key 3가지로 하나라도 변경되었으면 렌더링이 필요하다고 판단한다.

우리가 보통 span 태그를 사용하다가 div태그로 변경된다면 이것은 리렌더가 필요하다고 생각한다.

더불어 props 변경은 자연스레 리렌더가 필요하다고 생각하며, key를 변경하여 강제로 리렌더를 시킨 경험도 있을 것이다.

#### 커밋 단계
렌더 단계의 변경 사항을 실제 DOM에 적용하는 과정이다.

리액트가 DOM을 커밋 단계에서 업데이트한다면 만들어진 모든 DOM 노드 및 인스턴스를 가르키도록 내부 참조를 변경한다.

그 후 class 컴포넌트의 경우 componentDidMount, componentDidUpdate, 메서드를 호출, 함수형 컴포넌트는 useLayoutEffect를 호출한다.

**중요한 점**은 리액트의 렌더링이 일어난다고 무조건 DOM 업데이트가 일어나는 것은 아니다.

이렇게 렌더와 커밋 단계로 이뤄진 리액트 렌더링은 동기식으로 작동했으나, 특정 컴포넌트의 렌더링이 오래 걸린다면 다른 컴포넌트의 렌더링이 늦어질 수 있다.
결과적으론 브라우저가 블로킹되는 현상이 발생한다.

이를 해결하기 위해 조금 더 유연하고 우선순위를 정해줄 수 있는 방법이 필요했고, 이를 위해 동시성 렌더링이 도입되었다.
이는 리액트의 렌더링을 비동기적으로 처리할 수 있고, 우선순위를 지정, 중단, 재시작 등을 할 수 있게끔 해준다.

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

- useMemo
- useCallback
- React.memo

모두 리액트의 렌더링을 최소한으로 하기 위해 제공하는 기능이다.

[리액트 공식 문서](https://react.dev/reference/react/useMemo)에서 제공하는 useMemo를 해야할 때 가이드? 에서는 연산 작업이 1ms 이상 걸릴 때 사용하라고 권장한다.
> 저도 상기 공식문서를 읽고 무거운 작업, 혹은 비싼 작업이나 or 범용적인 훅에서만 사용하고 있습니다!

> 참조 투명성을 유지시켜주고, 실제 사용하는 사람은 굳이 이런 것들을 신경쓰지 않아도 되게끔 해주려고 하는 편인데요, 실제로
> 콜백함수가 useEffect의 의존성 배열로 들어갔을 때를 처리해주기 위해선 바깥에서 넘겨줄 때 useCallback으로 감싸주는 것 or
> 해당 훅 내부에서 usePreserveCallback을 만들어 적용해 주었던 것 같습니다.
> 
> 여타 다른 라이브러리들도 이런 식으로 설계되어 있던데 흠흠,, 
> 
> 다른 분들께서는 useMemo, useCallback 많이 사용하시나요? 더불어 useEffect 의 의존성 배열의 rule of hooks를 잘 지키시는 편인가요?!

> 커스텀훅을 만들어서 핸들러를 내보내는 반환 값에 useMemo를 사용하는 경우가 있을까요?