# 리액트 핵심 요소 깊게 살펴보기

## JSX

JSX의 설계 목적은 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점을 두고 있다

### 요소명은 대문자로 시작해야만 되는 거 아닌가요?

리액트에서는 컴포넌트를 만들어 사용할 때 반드시 대문자로 시작해야 한다.

이는 JSXElements 표준에는 없는 내용인데, 왜냐하면 리액트에서 HTML 태그명과 사용자가 만든 컴포넌트 태그명을 구분 짓기 위해서다.

* textarea, a, span 같은 현존하는 HTML 태그만 필터링하지 않고 이런 규칙을 둔 이유는 미래에 추가될 HTML 태그에 대한 가능성을 열어두며, 사람이 확실히 구별할 수 있게 하기 위함으로 보인다.

---

* 대부분의 리액트 개발자들은 `<Foo attr={<div>foo</div>}`와 같이 값으로 들어가는 리액트 컴포넌트를 {}로 감싸는 게 익숙할텐데, 이것은 문법적인 오류가 아닌 프리티어의 규칙이다.

### JSX는 어떻게 자바스크립트에서 변환될까?

* JSX가 변환되는 방식을 알려면 리액트에서 JSX를 변환하는 `@bable/plugin-transform-react-jsx` 플러그인을 알아야 한다.

* JSX 반환값이 결국 `React.createElement` 함수로 귀결된다.

## 가상 DOM과 리액트 파이버

* 가상 DOM에 대해 가지고 있는 일반적인 오해는 리액트의 이러한 방식이 DOM을 관리하는 브라우저보다 빠르다는 사실이다.
  + 이는 사실이 아니라고 댄이 부정한 바 있다.
  + 무조건 빠른 것이 아니라 리액트의 이 가상 DOM 방식은 대부분의 상황에서 충분히 빠르다는 것이다.

<!-- 오혜성이 추가한 내용 -->

```
벌써 한 2년전에 쓴 블로그 포스트가 있는데요.
https://www.hyesungoh.xyz/whyVirtualDom

svelte 개발자인 rich harris의 블로그 포스트와 같이 봐보면 좋을 것 같심더
```

### 리액트 파이버란?

* 리액트 파이버는 리액트에서 관리한느 평범한 자바스크립트 객체

* 파이버는 파이버 재조정자가 관리함
  + 이는 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하고
  + 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 함
  
* 파이버는 하나의 작업 단위로 구성되어 있음
  + 리액트는 이러한 작업 단위를 하나씩 처리하고 `finishWork()`라는 작업으로 마무리
  + 이후 해당 작업을 커밋해 실제 DOM에 가시적인 변경 사항을 만들어 냄

```
1. 렌더 단계에서는 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행함
1.1. 해당 단계에서 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 작업이 일어남

2. 커밋 단계에서는 DOM에 변경 사항을 반영하기 위한 작업(commitWork)이 실행됨
2.1. 이는 동기식으로 일어나고 중단될 수 없음
```

* 파이버는 가급적으로 재사용되도록 설계되어 있음
  + 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적 재사용

* 파이버는 하나의 element에 하나가 생성되는 1:1 관계를 가지고 있음
  + 1:1로 매칭된 정보를 가지고 있는 것이 `tag`
  + 이는 리액트 컴포넌트일 수도, DOM 노드일 수도 혹은 다른 것일 수도 있음

* `memoizedState` 함수형 컴포넌트의 훅 목록이 저장되며, 모든 훅 리스트가 저장됨

<!-- 오혜성이 추가한 내용 -->

```
훅을 배열로 관리하는 것과 관련해 읽었던 아티클이 생각나서 공유드립니당

https://pozafly.github.io/react/react-is-managing-hooks-as-an-array/
```

* 리액트 개발 팀은 사실 리액트는 가상 DOM이 아닌 Value UI라는 내용을 피력한 바 있음
  + 값을 가지고 있는 UI
  + 리액트의 핵심 원칙은 UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것
  + 변수에 이러한 UI 관련 값을 보관하고, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고, 표현하는 것이 바로 리액트다.

### 파이버 트리

파이버 트리는 사실 리액트 내부에서 두 개가 존재한다.

* 하나는 현재 모습을 담은 파이버 트리
* 다른 하는 작업 중인 상태를 나타내는 workInProgress 트리

리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버린다.
* 이런 개념을 더블 버퍼링이라고 한다

더블 버퍼링은 커밋 단계에서 수행된다

### 파이버의 작업 순서

1. 루트 노드에서 `beginWork`
2. 자식이 있을 시 자식으로 이동해 `beginWork`
3. 자식이 없을 경우 `completeWork`
4. 형제가 있을 경우 넘어가서 `beginWork`

결국 DFS다

생성 이후 여기서 setState 등으로 업데이트가 발생하면 어떻게 될까?

* 최초 렌더링 시에는 모든 파이버를 새롭게 만들지만, 이후에는 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다
  + 재조정 마다 파이버 객체를 만드는 것은 리소스 낭비, 그렇기 때문에 파이버 객체의 내부 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트 한다

* 과거 동기식으로 처리했다는 작업이 바로 이 작업
  + 트리의 업데이트 과정을 동기식으로 만들어 중단될 수 없었따
  + 현재는 우선순위가 높은 다른 업데이트가 오면 현재 작업을 일시 중단하거나, 새롭게 만들거나, 폐기할 수도 있다
  + 작업 단위를 나누어 우선순위를 할당하는 것 또한 가능하다.
  + 리액트는 이러한 작업을 파이버 단위로 나눠서 수행한다

<!-- 오혜성이 추가한 내용 -->

```
여러분의 useTransition, useDeferredValue 사용 경험이 궁금합니다
```

### 파이버와 가상 DOM

실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야 하고, 또 처리하는 작업이 많아 화면에 불완전하게 표시될 수 있는 가능성이 높으므로 이러한 작업을 가상에서, 즉 메모리상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것

* 가상 DOM은 웹 어플리케이션에서만 통용되는 개념
  + 파이버와 가상 DOM은 동일 개념이 아니다

* 가상 DOM과 파이버는 빠르다는 이유로 만들어진 것이 아닌
  + 개발자가 편하게, 선언적으로 UI를 작성하고 유지보수할 수 있도록 하기 위함
  + 핵심은 값으로 UI를 표현하는 것

## 클래스형 컴포넌트와 함수형 컴포넌트

* 클래스 필드 문법
  + ES2022에 추가됨
  + 별도의 초기화 과정을 거치지 않고도 클래스 내부에 필드를 선언할 수 있게 도와줌
  
* `<button onClick={() => foo()}>foo</button>`
  + 매번 렌더링이 일어날 때마다 새로운 함수를 할당해 최적화를 수행하기 어렵다. 지양하는 것이 좋다

### 클래스형 컴포넌트 생명주기

* shouldComponentUpdate
  + 명시적으로 업데이트할 지를 반환할 수 있음
  
<!-- 오혜성이 추가한 내용 -->

```
해당 메서드를 사용하기 위해 클래스형 컴포넌트로 작성된 프로젝트를 본 적 있음
```

* extends `Component` vs `PureComponent`
  + 퓨어 컴포넌트가 state 값에 대해 얕은 비교를 수행해 결과가 다를 때만 렌더링을 수행한다

* static getDerivedStateFromProps
  + render를 호출하기 직전에 호출
  + 여기서 반환되는 객체는 모두 state로 들어가게 된다
  + 모든 render 실행 시에 호출
  
* getSnapShotBeforeUpdate
  + 여기서 반환되는 값은 componentDidUpdate로 전달된다
  + DOM에 렌더링되기 전에 윈도우 크기를 조절하거나 스크롤 위치를 조정하는 등의 작업을 처리하는 데 유용

* getDerivedStateFromError
  + 에러가 발생했을 때 호출되는 메서드
  + 반드시 state를 반환해야 함
    - 하위 컴포넌트에서 에러가 발생했을 경우 어떻게 자식 컴포넌트를 렌더링할지 결정하는 용도로 제공되기 떄문에
  + 렌더링 과정에서 호출되기 떄문에 부수효과를 발생시켜선 안됨
    - state를 반환하는 것 외의 모든 작업
    - componentDidCatch에서 부수효과를 핸들링

* componentDidCatch
  + getDerivedStateFromError에서 state를 결정한 이후에 실행
  + 커밋 단계에서 실행됨
  + 개발 모드와 프로덕션 모드에서 다르게 동작함
    - 개발 모드에서는 에러가 window까지 전파됨

### 클래스형 컴포넌트의 한계

* 데이터 흐름을 추적하기 어렵다
* 내부 로직 재사용이 어렵다
* 컴포넌트의 크기가 커진다
* 함수에 비해 상대적으로 어렵다
* 코드 크기를 최적화하기 어렵다
  + 번들 크기를 줄이는 데도 어려움을 겪는다
  + 메서드가 미니파이드되지 않고 사용하지 않는 메서드도 트리 쉐이킹이 되지 않는다
* 핫 리로딩을 하는 데 상대적으로 불리하다
  + 클래스형 컴포넌트는 최초 렌더링 시에 인스턴스를 생성하고 그 내부에서 state를 관리한다
  + 렌더가 변겨되면 이를 반영하는 방법은 인스턴스를 새로 만드는 것 뿐이다

### 함수형 컴포넌트와 렌더링된 값

* 함수형 컴포넌트는 렌더링된 값을 고정하고, 클래스형 컴포넌트는 그렇지 못하다
  + 클래스형 컴포넌트는 props 값을 항상 this로부터 가져온다
  + this가 가리키는 객체, 인스턴스는 변경 가능한 값이다
  + 따라서 렌더 메서드를 비롯한 리액트의 생명주기 메서드가 변경된 값을 읽을 수 있다

* 함수형 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링된다

## 렌더링은 어떻게 일어나는가?

리액트의 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미한다
* 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다

### 렌더링이 일어나는 이유

* 최초 렌더링
* 리렌더링
  + 클래스형 컴포넌트의 setState가 실행되는 경우
  + 클래스형 컴포넌트의 forceUpdate가 실행되는 경우
    - shouldComponentUpdate를 무시하고 건너뛴다
  + 함수형 컴포넌트의 useState()의 setter가 실행되는 경우
    - 이 함수가 실행되면 렌더링이 일어난다
  + 함수형 컴포넌트의 useReduce()의 dispatch가 실행되는 경우
  + 컴포넌트의 key props가 변경되는 경우
    - key가 없다면 단순히 파이버 내부의 형제 인덱스만을 기준으로 판단하게 된다
    - key를 활용해 강제로 리렌더링을 일으키는 것이 가능
  + props가 변경되는 경우
  + 부모 컴포넌트가 렌더링될 경우

<!-- 오혜성이 추가한 내용 -->

```
useState
- 리액트의 렌더링은 실행만 해도 일어남
- 하지만 브라우저의 렌더링은 변경이 있을 때만 일어남
```

<!-- 오혜성이 추가한 내용 -->

```
key props를 바꾸어 리렌더링하는 구현을 자주 사용하곤 합니다
- 애니메이션을 다시 재생해야되는 경우에 써먹는 거 같아요
```

### 리액트의 렌더링 프로세스

* 렌더링 프로세스가 실행되면서 각 컴포넌트의 렌더링 결과물을 수집
* 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 수집
  + 재조정

* 재조정이 끝나면 모든 변경 사항을 하나의 동기 시퀸스로 DOM에 적용

### 렌더와 커밋

* 렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
  + 컴포넌트 실행 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계
  + 크게 type, props, key를 비교함
  + 리액트의 렌더링이 일어난다고 무조건 DOM 업데이트가 일어나는 것이 아님

## 메모이제이션

리액트 커뮤니티에서 오랜 논쟁 주제로
* 무조건 메모이제이션이 필요하다
* 메모이제이션을 섣불리 해서는 안 된다
가 있다

* 규모가 커지고, 개발자가 많아지고, 컴포넌트 복잡성이 증가하는 상황에서
  + 실무에 임하는 모든 개발자들은 생각보다 최적화나 성능 향상에 쏟을 시간이 많지 않다는 사실에 모두 공감할 것이다

* 리액트는 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장해 둬야 한다
  + 기본적인 리액트 재조정 알고리즘
* 따라서 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐

* 참조의 투명성
<!-- 오혜성이 추가한 내용 -->

```
대다수의 라이브러리가 참조의 투명성, 동일성을 위해 useMemo, useCallback을 사용하는 것을 볼 수 있음
```

### 저자 생각

시간적 여유가 없다면 일단 의심스러운 곳에는 먼저 다 적용해 볼 것을 권장

* 일반적으로 props에 대한 얕은 비교보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비싸다

* 섣부른 메모이제이션 최적화가 주는 이점이 더 클 수 있다.
