## 2.1 JSX 란?

- JSX는 리액트에 종속된 문법은 아니다.
- 자바스크립트 표준 문법도 아니며 페이스북이 임의로 만든 새로운 문법이기 때문에 트랜스파일러를 거쳐야 비로소 자바스크립트 런타임이 이해할 수 있는 의미있는 자바스크립트 코드로 변환

### 2.1.1 JSX의 정의

- JSXElement
- JSXAttributes
- JSXChildren
- JSXStrings

### 2.1.2 JSX 예제

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

- @babel/plugin-transform-react-jsx 플러그인이 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환한다.
- 반환값은 결국 React.createElement로 귀결된다.

### 2.1.4 정리

- JSX는 자바스크립트 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있다는 점에서 각광받고 있다.

## 2.2 가상 DOM과 리액트 파이버

### 2.2.1 DOM과 브라우저 렌더링 과정

- DOM이란 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.
- 브라우저의 렌더링 과정
    
    1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드 한다.
    
    2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리 (DOM)을 만든다.
    
    3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
    
    4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다.
    
    5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고 사용자 눈에 보이는 노드만 방문한다.
    
    즉, display: none과 같이 사용자 화면에 보이지 않는 요소는 방문해 작업하지 않는다. 이는 트리를 분석하는 과정을 조금이라도 빠르게 하기 위해서이다.
    
    6. 5번에서 제외된 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다.
    
    이 DOM 노드에 CSS를 적용하는 과정은 크게 두 가지로 나눌 수 있다.
    
    - 레이아웃(layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정, 이 레이아웃 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
    
    - 페인팅(painting): 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정
    

### 2.2.2 가상 DOM의 탄생 배경

- 렌더링 과정은 매우 복잡하고 많은 비용이 든다. 여기서 사용자의 인터랙션이 더해지면 훨씬 복잡한 작업을 수행해야 한다.
- 특히 Single Page Application 에서는 페이지가 변경되는 경우 하나의 페이지에서 계속해서 요소의 위치를 재계산하기 때문에 그만큼 DOM을 관리하는 과정에서 부담해야 할 비용이 커진다.
- 이 문제를 해결하기 위해 탄생한 것이 바로 가상 DOM이다.
- 가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료되었을 때 실제 브라우저의 DOM에 반영한다.
- 가상 DOM은 브라우저에서 변경이 일어나는 것이 아니라 메모리에서 계산하는 과정을 거치는 것이기 때문에 브라우저와 개발자의 부담을 덜 수 있다.

### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

- 리액트 파이버는 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.
- 비동기로 이루어 진다.

## 2.3 클래스형 컴포넌트와 함수형 컴포넌트

### 2.3.1 클래스형 컴포넌트

- constructor()
- props
- state
- 메서드
- 클래스형 컴포넌트의 생명주기 메서드
    
    - 마운트: 컴포넌트가 생성되는 시점
    
    - 업데이트: 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
    
    - 언마운트: 컴포넌트가 더 이상 존재하지 않는 시점
    
    - render(): 마운트와 업데이트 과정에서 일어난다. 이 함수는 항상 순수해야 하며 부수 효과가 없어야 한다.
    - componentDidMount(): setState로 state 변경이 가능하지만 생성자에서 할 수 없는 것, API 호출 후 업데이터, DOM에 의존적인 작업(이벤트 리스너 추가) 등을 하는 작업 이외에 남용하지 말 것.
    - componentDidUpdate(): setState로 state 변경이 가능하지만 적절한 조건문을 통해 성능 이슈가 발생하지 않도록 할 것.
    - componentWillUnMount(): setState를 호출할 수 없다. API 호출을 취소하거나 setInterval, setTimeout 타이머를 지우는 작업에 유용
    - shouldComponentUpdate(): state나 Props의 변경으로 리렌더링 되는 것을 막고 싶다면 이 메서드를 사용하면 된다.
    - static getDerivedStateFromProps(): render()를 호출하기 직전에 호출되며 여기서 반환하는 객체는 state로 들어간다.
    - getSnapShotBeforeUpdate(): DOM이 업데이트되기 직전에 호출되어 componentDidUpdate로 반환값이 전달된다. DOM에 렌더링 되기 전에 윈도우 크기를 조절하거나 스크롤 위치를 조정하는 작업에 유용
    - getDerivedStateFromError(): 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드.
    - componentDidCatch(): 자식 컴포넌트에서 에러가 발생했을 때 실행, getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행
- 클래스형 컴포넌트의 한계
    - 데이터 흐름을 추적하기 어렵다. 서로 다른 여러 메서드에서 state의 업데이트가 일어날 수 있기 때문
    - 애플리케이션 내부 로직의 재사용이 어렵다.
    - 기능이 많아질수록 컴포넌트의 크기가 커진다.
    - 클래스는 함수에 비해 상대적으로 어렵다.
    - 코드 최종 번들 크기를 최적화하기 어렵다.
    - 핫 리로딩(애플리케이션을 실행한 채로 코드의 수정 내용이 바로바로 반영되는 것)을 하는데 상대적으로 불리하다.

### 2.3.2 함수형 컴포넌트

### 2.3.3 함수형 컴포넌트 vs 클래스형 컴포넌트

- 생명주기 메서드의 부재
    - 함수형 컴포넌트는 useEffect 를 활용해서 생명주기 메서드를 비슷하게 구현할 수 있다.
- 함수형 컴포넌트와 렌더링된 값
    - 함수형 컴포넌트는 렌더링이 일어날 때 마다 그 순간의 값인 props와 state를 기준으로 렌더링된다. props와 state가 변경된다면 다시 한번 그 값을 기준으로 함수가 호출된다. 반면 클래스형 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다.

## 2.4 렌더링은 어떻게 일어나는가?

### 2.4.1 리액트의 렌더링이란?

- 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정

### 2.4.2 리액트의 렌더링이 일어나는 이유

- 최초 렌더링
- 리렌더링
    - class component - setState가 실행되는 경우
    - class component - forceUpdate가 실행되는 경우
    - function component - useState()의 두번째 배열 요소인 setter가 실행되는 경우
    - function component - useReducer()의 두번째 배열 요소인 dispatch가 실행되는 경우
    - 컴포넌트의 key props가 변경되는 경우
    - props가 변경되는 경우
    - 부모 컴포넌트가 렌더링될 경우 자식 컴포넌트도 무조건 리렌더링 된다.

### 2.4.3 리액트의 렌더링 프로세스

- 재조정 (Reconciliation)

### 2.4.4 렌더와 커밋

- 렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업 (type props key 중 변경 사항을 가상 DOM과 비교해 변경이 필요한 컴포넌트를 체크하는 단계)
- 커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정

### 2.4.5 일반적인 렌더링 시나리오 살펴보기

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

- useMemo
- useCallback
- memo

### 2.5.1 주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자.

- 렌더링도 비용이지만 메모리에 저장하는 것도 마찬가지로 비용이다.
- 메모이제이션으로 인한 성능 개선이 렌더링보다 낫지 않다면 결국 안하느니만 못하는 상황이다.

### 2.5.2 주장 2: 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션 해 버리자.

- memo 작업은 리액트의 재조정 알고리즘과 비슷해 이미 저장되고 있다.
- 결론적으로는 메모이제이션은 하는 것이 더 좋다.
- 비록 섣부른 초기화라고 할지라도 했을 때 누릴 수 있는 이점, 이를 실수로 빠뜨렸을 때 치러야할 위험 비용이 더 크기 때문에 가능한 모든 곳에 메모이제이션을 하자.