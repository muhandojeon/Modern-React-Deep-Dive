# 2장 리액트 핵심 요소 깊게 살펴보기

## 2.1 JSX란?

JSX는 리액트 이외에서도 Preact, Solid 등에서도 사용되는 문법이다.

JSX는 반드시 트랜스파일(브라우저가 이해할 수 있는 코드로 변환) 과정을 거쳐야 한다.

JSX는 JSXElement, JSXAttributes, JSXChildren, JSXStrings 4가지 컴포넌트를 기반으로 구성되어있음


## 2.2 가상 DOM과 리액트 파이버

### 가상 DOM의 오해
가상 DOM은 일반적인 DOM 조작보다 항상 빠르지 않다. (단지, snapshot을 비교해서 변경된 부분만 업데이트하기 때문에 빠르다고 오해할 수 있음)

### 리액트 파이버

파이버 도입 이전에는 렌더링을 중단될 수 없었다. 

렌더링은 아래 두 단계를 거쳐 일어난다.
1. 렌더 단계
   렌더 단계에서 key, state, props를 비교해서 변경된 컴포넌트들을 체크한다.
   사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 해당 단계에서 파이버 우선순위를 지정, 중단하는 작업이 일어난다.
2. 커밋 단계 (더블 버퍼링 기법)
   해당 작업은 DOM에 실제 변경사항을 반영한다.

파비머노드는 자바스크립트 객체로 이루어져 있다.
파이버도 컴포넌트 트리와 같이 트리 형식으로 구성된다.


## 2.3 클래스 컴포넌트와 함수 컴포넌트

### 클래스 컴포넌트의 한계
1. 데이터의 흐름을 추적하기 어렵다.
2. 내부 로직의 재사용이 어렵다.
   재사용 하기 위해 고차 컴포넌트를 사용하는데, 이는 로직과 데이터의 응집도가 떨어지고, 많은 wrapper로 인해 가독성이 떨어진다고 생각이 든다.
3. 컴포넌트 크기가 커진다.
4. 클래스는 함수에 비해 상대적으로 어렵다. (this..)
5. 코드 크기를 최적화하기 어렵다.
   1. minified 불리
   2. 트리 셰이킹 지원 불리

6. 핫리로딩 시 상태 초기화
    instance를 새로 생성하기 때문에 상태가 초기화 된다.

### 렌더링은 어떻게 일어나는가?

주요 리렌더링 조건
1. state, props 변경
2. useReducer의 dispatch 호출
3. key가 변경된 경우
 * key는 주로 리스트에서 사용하는데, key가 변경되면 해당 컴포넌트가 리렌더링 된다. 또한, 애니메이션에도 key를 사용하여 애니메이션을 트리거를 종종 사용하여 트리거하면 유용했던 것 같다.
 * key값으로 Math.radom()과 같은 변경되는 값을 사용하면 안되는 이유는, key값이 변경되면 해당 컴포넌트가 리렌더링 되기 때문이다



## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

책에서는 memo를 적극적으로 사용하자는 관점과, 필요한 경우에만 사용하자는 관점을 모두 소개하고, 저자는 항상 메모이제이션을 사용하자는 관점을 따르고 있다.

나는 아래 이유 때문에 필요한 경우에만 사용하자는 생각이다.

1. 가독성 (memo, useCallback, useMemo를 사용하면 코드 양이 많아질 수 밖에 없다.)
2. 일반적인 경우에 memo로 얻는 성능 이점이 있는가?
3. 멀지 않은 미래에 React Forget 컴파일러가 도입되고, memo를 사용하지 않아도 성능 이점을 얻을 수 있을 것이다.
4. memo를 사용하는 것이 항상 권장된다면, 왜 리액트 설계 상 memo가 default로 적용되지 않았을까?