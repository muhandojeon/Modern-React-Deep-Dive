## 이상조

- 리액트 톺아보기 블로그 글 보면서 그거 기반으로 정리했음
- 파이버라는 애를 2개로 나눠서 이야기 함
  - 파이버 아키텍처 - 스택을 기준으로 하기 때문에 useTransition 등 렌더링 우선 순위 조작이 가능한 것
  - 파이버 노드 - react element에서 hook, 상태, 라이프사이클 → 가상돔 트리다.
- 리액트는 여러 상태 변경 작업들을 모두 진행하고 나서 render phase를 진행한다.

## 서준환

- <S:S> <A.B.C> 이런 형식으로도 JSX 문법이 있구나를 처음 알았다.
- 상태 동기화할 때 불필요한 useEffect를 사용하지 않는 것을 추천한다. 는 글을 읽은 적이 있었음
- useEffect 쓰는 것 좋아하시나요?
  - 대윤: 우리팀장님 말로는 말그대로 side-effect가 없어야되서 사용을 줄이라고하더군요..
  - 동규: React를 쓰지말아야하는 이유 라는 아티클에서도 SideEffect를 없애야 하는데 React는 오피셜로 제공하고 있어서 사용하지말자
- 메모이제이션을 해야할까? 말아야할까?
  - 리액트 공식 문서에서는 연산 작업이 1ms 이상 걸릴 때만 사용하라고 권장
  - custom hook을 만들 때 참조 투명성을 유지하기 위해서는 써주는 것이 좋다.

## 오혜성

- JSX는 맛이 없어..
  - 현실 세계에서 가까이 다루지 않는 경우가 훨씬 많다.
  - 컴포넌트 만들 때 대문자로 쓰는 이유는 흥미로웠다. HTML 태그의 확장성을 위해서다!
  - 엘리먼트를 넣을 때 괄호 안에 넣어주는게 프리티어의 규칙이라는 점이 재밌었다.
- 파이버
  - 젤 중요하고 잼썼다.
  - 가상 DOM이 있는 이유는?
    - 무조건 빨라서는 아니다!
    1. 일반적으로 빠르다. 2. 선언적으로 쓸 수 있는 방법을 제공한다. 라는 것이 장점인 것
  - memoizedState 훅 리스트가 저장됨
    - 훅을 배열로 관리한다는 레퍼런스가 좋았음 https://pozafly.github.io/react/react-is-managing-hooks-as-an-array/
  - 리액트 개발자는 가상 DOM 보다는 value UI라는 표현이 좋다고 한다는 부분이 흥미
  - 작업 순서는 결국 DFS다.
- JSX에 함수 넣어서 쓰는 부분이 렌더링 일어날 때마다 함수를 할당해서 최적화를 수행하기 어렵다고 하는데… 근데 그러면 렌더링 일어날 때 마다 새로운 함수 할당 안하려면 useCallback을 쓸 수 밖에 없지 않나?
- 클래스 생명 주기
  - shouldComponentUpdate 부분은 업데이트 할지 말지에 대해서 반환할 수 있다.
  - 그런데 함수 컴포넌트의 경우에는 인터페이스가 없다보니까 저 메소드 쓰려고 클래스형 컴포넌트로 만드는 것도 본적있음
- 에러바운더리
  - 하라는대로 했었는데 그 세부적인 차이를 알게 되었다.
- 리액트 렌더링 vs 브라우저 렌더링 차이를 다시 알 수 있었음.
  - useState는 실행만 해도 리액트 렌더링이 일어나지만, 브라우저 렌더링은 상태 값이 변경될 때 일어난다.
- 대다수의 라이브러리가 참조의 투명성, 동일성을 위해서 useMemo, useCallback을 쓰고 있더라
- 메모이제이션은 다 쓰자는 의견에 조금 더 설득이 되었다.

## 김동규

- 가상 DOM 나왔을 때 대충 DOM 트리 비교해서 필요한 것만 바꿔준다 정도로만 알고 있었는데 더 자세히 알 수 있었다.
- 파이버 메모이제이션 관련 내용을 보면서 GIthub million 이라는 라이브러리를 봤는데, 최적화 성능을 끌어올렸다고 자랑하더라!
- 파이버란?
  - 평범한 자바스크립트 객체
  - 스택 알고리즘의 대안으로 나왔다.
  - 렌더 단계, 커밋 단계
    - 렌더 단계: 보이지 않는비동기 작업 수행
    - 커밋 단계: 실제 DOM에 반영하는 작업을 동기적으로 수행
  - workInProgress 트리 비교 과정을 더블 버퍼링 과정이라고 하는데 커밋 단계에서 수행된다.
- 클래스형 컴포넌트에서 함수형으로 바꾼 이유
  - 성능상의 이유다
  - 데이터 흐름 추적이 어렵다
  - 내부 로직 재사용이 어렵다
  - 기능이 많을 수록 컴포넌트가 커진다.
  - 함수에 비해 어렵다.
- 메모이제이션
  - 모두 하자에 한 표!

## 정대윤

- JSX가 HTML, JS가 섞여서 가독성을 해칠 수 있다고 하니 주의하고 적절한 lint를 사용하자.
- Virtual DOM 과 Fiber
  - 파이버 생각보다 영향력 있어..
  - Virtual DOM은 무조건 빠르다는 아니고 충분히 빠르다.
- 렌더와 커밋
  - 동기적으로 일어나는구나 → 그래서 이 과정이 길어지면 성능 저하가 일어난다.
  - 리액트 18에서 동시성 렌더링이 이래서 적용된 거구나 (useTransition 등)
  - useTransition은 input 같은데 쓰면 좋다고 어디서 보긴 함.
- 에러 바운더리
  - 렌더와 커밋 단계를 나눠서 처리해서 효율적이구나
  - 렌더 필요없는 것은 componentDidCatch로 처리하면 되는구나
- 함수 감쌀 때 display name을 적는 경우도 있고 안적는 경우도 있었는데 명시적으로 알 수 있었다.

## 이은지

- JSX 도 막연한 개념들을 정리할 수 있어서 좋았다.
  - 합성 컴포넌트에서 쓰이는 문법이 뭐지 하고 신기했었는데 여기서 알게 되었음
- 파이버
  - 리액트의 핵심을 한 문장으로! 리액트의 핵심은 UI 관련 값을 변수에 보관하고 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고 표현하는 것
  - DOM 요소에 직접 접근해서 값을 변경하던 jquery 시절과 비교해보면 이해가 된다.
  - UI가 오로지 props 나 state 같은 데이터에 디펜던스 하게 움직인다 UI는 그냥 표현일 뿐!
  - 재조정을 효과적으로 하기 위해서 만들어진 개념!
  - 파이버는 작업 단위를 의미한다.
- 렌더링
  - UI를 계산하는 과정이다.
  - 렌더링은 계산이므로 렌더링이 반드시 DOM 업데이트로 이어지는 것은 아니다.
  - 상태관리 패키지의 존재 이유

## 권오연

- 다양한 JSX 문법들을 보면서 과연 이걸.. 언제 쓰려나.. 이 책 안읽어본 사람은 이해 못하는 문법이 과연 좋은 코드일까..
- 클컴의 생명주기 함수가 함컴의 useEffect와 동일하지 않다는 것
- 에러바운더리에서 클래스 컴포넌트를 쓸수밖에 없는 이유를 다시 자세히 볼 수 있어서 좋았고
- 클래스 컴포넌트가 안없어지는구나..

## 에러바운더리에 대한 단상

- try catch
- react query onError
- Error boundary 셋 다 쓰는게 좋은가?
- https://fe-developers.kakaoent.com/2022/221110-error-boundary/
