- # 2장
  - ## JSX
    - 자바스크립트 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있도록 만드는 문법 (JS Syntax Extension)
    - 자바스크립트 표준(ECMA Script)이 아니다. 따라서 자바스크립트 엔진(V8, Deno 등)과 브라우저에서 JSX 코드를 바로 실행하면 에러가 난다. 트랜스파일러를 거쳐야 자바스크립트 런타임이 이해할 수 있는 코드로 변환된다.
    - 변환 방식
      - 바벨 플러그인을 통해 이뤄진다. (@babel/plugin-transform-react-jsx)
      - JSX의 변환값은 `React.createElement`의 호출이다.
        - React.createElement
          - `const element = createElement(type, props, ...children)`
          - JSXElement를 첫 번째 인수로 선언한다. 나머지 세 컴포넌트는 이후 인수로 넘겨준다.
            - JSX의 변환값이 createElement의 호출이라는 사실을 활용한 리팩터링

    - 4가지의 컴포넌트로 이뤄져 있다.
      - JSXElement: HTML의 엘리먼트와 비슷한 역할을 한다.
        - JSXMemberExpression
          - *합성 컴포넌트?*
            ```
              <Dialog.CheckBox hasArrowButton>버튼명</Dialog.CheckBox>
              <Dialog.CheckBox hasArrowButton>버튼명</Dialog.CheckBox>
            ```
      - JSXAttributes
      - JSXChildren
      - JSXStrings

  - ## 가상 DOM
    - DOM: 웹 페이지에 대한 인터페이스. 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.
    - 가상 DOM의 등장 배경
      - 브라우저의 렌더링은 비용이 많이 든다.
        - SPA일 경우 더욱 그렇다. *하나의 페이지에서 계속해서 요소의 위치를 재계산하게 되기 때문에*
      - 사용자의 인터랙션에 따른 DOM의 잦은 변경이 필요하다. 이 모든 변경 사항을 개발자가 직접 추적하기 어렵다.
    - 가상 DOM
      - DOM을 일단 메모리에 저장, 리액트가 *실제 변경에 대한 준비가 완료되었을 때* 실제 브라우저의 DOM에 반영.
      - DOM 계산을 브라우저가 아닌 메모리에서 계산 → 여러 번 발생했을 렌더링 과정을 최소화할 수 있다.
  - ## 리액트 파이버, 리액트 렌더링
    - 리액트의 핵심 = UI 관련 값을 변수에 보관, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고 표현하는 것
      - JQuery와 비교해보면 이 문장을 조금 더 명확히 이해할 수 있다. *DOM 요소에 직접 접근해서 값을 변경하던 그 시절...* 
      - 두 가지 뜻으로 들린다.
        - UI가 오로지 props, state에 완전히 디펜던트하게 움직인다. UI는 데이터의 표현일 뿐이라는 컨셉이 담겨 있다. 값이 변하면 reactive 하게 화면이 변경되는. one-way binding.
        - 리액트 컴포넌트의 결과물이 html 텍스트가 아니라는 것
    - 리액트의 렌더링이란
      - 리액트 어플리케이션 트리 내 모든 컴포넌트들의 **UI를 계산**하는 일련의 과정
        - 렌더링 = 계산이므로, **렌더링이 반드시 DOM 업데이트로 이어지는 것은 아니다.** 렌더링이 발생했지만 DOM의 가시적인 변경은 일어나지 않을 수 있다.
      - 렌더링이 일어나는 시나리오는 정해져있다. 이 시나리오에 해당하지 않을 경우 렌더링이 절대 발생하지 않는다.
        - mobx-react, react-redux 등 리액트 패키지의 존재 이유
          - useState로 관리되지 않는 단순 변수는 아무리 값이 변경되어도 렌더링이 발생하지 않는다. 즉 Mobx, Redux가 관리하는 상태값은 리액트의 리렌더링으로 이어지지 않는다.
          - 따라서 리액트 패키지가 라이브러리의 변경된 상태를 바탕으로 리액트의 렌더링 시나리오 중 하나를 사용해 리렌더링을 발생시키는 것.
        - 렌더링 시나리오
          - 사용자의 최초 앱 진입
          - 클래스형 컴포넌트의 setState
          - 함수형 컴포넌트의 `useState - setter`의 실행
          - 함수형 컴포넌트의 `useReducer - dispatch`의 실행
          - 컴포넌트의 key props가 변경
          - props가 변경
          - 부모 컴포넌트가 렌더링되는 경우
            - 컴포넌트의 렌더링 작업은 별도로 렌더링을 피하기 위한 조치가 돼 있지 않는 한 모든 하위 컴포넌트에 영향을 미친다. 부모 컴포넌트의 UI를 계산 → 자식 커모넌트의 UI를 계산
    - 리액트 파이버란
      - 재조정(reconciliation)
        - 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업
        - **파이버는 이 재조정을 효과적으로 하기 위해 만들어진 개념**
          -
      - 생성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다. 리액트가 파이버를 처리할 때마다 이러한 작업을 바로 처리하기도 하고 **스케줄링하기도 한다.**
      - 파이버 트리
        - 리액트 내에 두 개 존재한다. current, workInProgress
        - 더블 버퍼링 기법
          - 보이지 않는 곳에서 그 다음 그림을 미리 그리고, 다 그려지면 포인터만 새 그림으로 변경하는 방식
          - current에 업데이트가 발생하면 workInProgress 트리를 빌드하기 시작한다. 트리 빌드 작업이 끝나면 다음 렌더링에 이 트리를 사용한다.
      - 책에서 등장한 파이버 관련 모호하고 상충되는 표현들 🙄
        - 파이버는 객체다
        - 파이버가 실행된다
        - 리액트가 파이버를 처리한다
        - 파이버를 통해서 조정된다
      - [React 공식 문서에 링크된 파이버 설명글](https://github.com/acdlite/react-fiber-architecture?tab=readme-ov-file#what-is-a-fiber)
        - a primary goal of Fiber is to **enable React to take advantage of scheduling.**
        - A fiber represents a **unit of work**.
        - Fiber is reimplementation of the stack, specialized for React components. You can think of a single fiber as a **virtual stack frame**.
          - *stack frame: 스택 영역에 저장되는 함수의 호출 정보*
  - ## 클래스형 컴포넌트, 함수형 컴포넌트
    - 클래스형 컴포넌트 생명주기 메서드
      - getDerivedStateFromError
        - 자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드. 에러 발생 시 어떻게 자식 컴포넌트를 렌더링할지 결정하는 용도로 제공된다. 따라서 반드시 미리 정의해 둔 state 값을 반환해야 한다.
        - 렌더링 과정에서 호출되는 메서드이기 때문에 사이드 이펙트를 발생시켜서는 안된다.
      - componentDidCatch
        - 위 메서드에서 에러를 캐치하고 state를 결정한 이후에 실행된다.
      - ErrorBoundary
        - 경계 외부에서 발생한 에러는 또 다른 ErrorBoundary를 찾아간다. 찾지 못하면 에러는 throw된다.
    - 함수형 컴포넌트 v.s. 클래스형 컴포넌트
      - 클래스형 컴포넌트: this에 바인딩된 props를 사용한다.
      - 함수형 컴포넌트: 인수로 전달 받은 props를 사용한다.
  - ## 메모이제이션
    - 메모이제이션의 비용
      - 값을 비교하고 렌더링(재계산)이 필요한지 확인하는 작업
        - memo의 경우 props에 대한 얕은 비교로 충분하다.
      - 메모리로부터 이전 결과물을 꺼내옴
    - 메모이제이션을 하지 않았을 때 발생하는 역비용
      - memo
        - 렌더링 비용(계산)
        - 컴포넌트 내부의 복잡한 로직의 재실행
        - 위 두 가지가 모든 자식 컴포넌트에서 발생
        - 리액트가 구 트리와 신 트리를 비교
    - 결론
      - 메모이제이션 하셈