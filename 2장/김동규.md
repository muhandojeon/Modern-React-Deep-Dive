# 리액트 핵심 요소 깊게 살펴보기

리액트에서 자주 언급되는 핵심 개념을 깊게 알아본다!

## JSX

JSX는 리액트가 등장하면서 페이스북에서 소개 된 구문 이지만, 리액트에 종속되지 않은 독자적인 문법이다. 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일 트리 구문을 작성하는데 많은 도움을 주는 문법이다.

- `JSXElement` `JSXAttribute` `JSXChildren` `JSXString` 4가지 컴포넌트를 기반으로 구성되어 있다.

## 가상 DOM과 리액트 파이버

가상DOM은 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고있다. 가상 DOM은 DOM을 관리하는 브라우저 보다 무조건 빠른것이 아닌, 대부분의 상황에서 빠르다는 것 이다.

리액트 파이버는 브라우저가 아닌 환경에서도 적용 될 수 있기 때문에 가상 DOM과 동일한 개념은 아니다.

```
최근에 million(https://million.dev/) 이라는 라이브러리를 보았는데, 이건 이런 최적화 성능을 70퍼센트 끌어올렸다고 자랑하더라고요!
```

#### 리액트 파이버란

리액트에서 관리하는 평범한 자바스크립트 객체이고, 애니메이션 레이아웃 등 사용자 인터렉션에 반응성 문제를 해결한다. 파이버의 모든 과정은 비동기로 일어난다.

- 파이버 재조정자(fiber reconciler)는 가상 DOM과 실제 DOM을 비교해 변경 사항이 있으면 렌더링을 요청하는 역할을 한다.
- 재조정(reconciliation)은 가상DOM 실제DOM을 비교하는 작업(알고리즘) 이다.

#### 스택 알고리즘

원래 스택에 렌더링에 필요한 작업을 쌓으며 동기적으로 진행되고, 자바스크립트의 싱글스레드 특성 상 동기작업은 중단 되지 못해 이 방식은 비효율적이 되어 버렸다. 이 문제를 해결하기 위해 파이버라는 개념을 도입했다.

#### 리액트 파이버 구현

리액트 파이버는 하나의 작업단위로 구성되어 있으며, `finishedWork()` 함수로 작업을 마무리한다. **렌더 단계**와 **커밋 단계** 2가지로 나뉘어 브라우저 DOM에 가시적인 변경사항을 만들어낸다.

- 렌더단계, 사용자에게 노출되지 않는 비동기작업들을 수행한다.
- 커밋단계, DOM에 실제 변경사항을 반영하기 위한 작업을 동기적으로 수행한다.

#### 리액트 파이버 트리

리액트 파이버 트리에서는 현재의 모습을 담은 트리와 작업 상황을 담은 workInProgress 트리가 있다. 리액트 파이버의 작업이 끝나면 포인터만 변경하여 workInProgress 트리를 현재 트리로 바꿔버린다. 이 과정을 더블버퍼링 과정이라고 하며, 커밋 단계에서 수행된다.

## 클래스형과 함수형 컴포넌트

초기 함수형 컴포넌트는 단순히 요소를 정적으로 렌더링 하는 것이 목표였지만, 16.8 업데이트 이후 달라졌다.

#### 클래스형 컴포넌트

클래스형 컴포넌트를 사용하며 가장 많이 언급되는 것은 생명주기 이다.

- Mount, 컴포넌트가 생성 되는 시점
- Update, 이미 생성된 컴포넌트가 업데이트 되는 시점
- Unmount, 컴포넌트가 더 이상 존재하지 않는 시점

#### 클래스형 컴포넌트의 Render()

항상 순수해야하며 Side Effect가 없어야한다. render 함수 내부에서 setState를 호출해서는 안된다.

#### Pure Component와 일반 Component

shouldComponentUpdate 생명주기를 다룸에 있어서 차이가 있다. Pure Component는 얕은 비교만 진행하여 변경사항이 있을 경우 재 렌더링 시킨다.

#### ErrorBoundary

componentDidCatch는 개발모드와 프로덕션모드에서 다르게 동작한다. 개발모드에서는 에러가 발생하면 window까지 전파되고, 프로덕션모드에서는 잡히지 않는 에러만 전파된다.

#### 클래스형 컴포넌트의 한계

- 데이터 흐름을 추적하기 어렵다
- 애플리케이션 내부 로직의 재사용이 어렵다.
- 기능이 많아질수록 컴포넌트 크기가 커진다.
- 클래스는 함수에 비해 상대적으로 어렵다.

#### 클래스형 VS 함수형

클래스형은 항상 this를 참조하기에 중간에 값이 변경되는 경우 변경 된 값이 렌더링되고, 함수형은 렌더링이 일어난 순간의 값을 가지고 사용한다.

## 렌더링은 어떻게 일어나는가?

리액트에도 렌더링이라는 과정이 있으며, 비용이 소모되기 때문에 렌더링 과정을 최소한으로 줄여야한다.

### 리액트에 렌더링이 일어나는 이유

리액트에서 렌더링이 일어나는 타이밍은 아래와 같다.

- 최초 렌더링
- 클래스형 컴포넌트의 setState
- 클래스형 컴포넌트의 foreceUpdate
- 함수형 컴포넌트의 useState의 setter가 실행되는 경우
- 함수형 컴포넌트의 useReducer의 두 번째 요소인 dispatch가 실행되는 경우
- 컴포넌트의 key props가 변경 되는 경우
- props가 변경되는 경우
- 부모 컴포넌트가 리렌더링 되는 경우

### Key Props가 필요한 이유

리렌더링이 발생하는 동안 동일한 요소를 식별하는 식별값이고, 리액트 파이버의 현재와 workInProgress를 구분하는 값이다. 만약 키가 없다면, 단순한 파이버 내부의 index로만 비교하게 된다.

### 상태관리 라이브러리

mobx나 redux 같은 라이브러리들은 각자의 방법으로 상태관리를 해주다가 위의 리렌더링 트리거를 통해 리렌더링을 발생 시킨다.

### 렌더와 커밋

렌더 단계는 type,props,key 크게 3가지를 비교하여 변경이 필요한 컴포넌트인지 체크한다. 다음인 커밋단계에서 변경 사항을 실제 DOM에 적용한다. 하지만 이와같은 리액트 렌더링과정이 일어났다고 하여 무조건 DOM 업데이트가 일어나는 것은 아니다.

React 18에서 비동기 렌더링을 통해 먼저 보여줄 수 있는 화면을 먼저 보여주는 동시성 렌더링이 업데이트 되었다.

## 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

무조건 메모이제이션이 필요하다 라는 입장과 섣불리 해서는 안된다라는 2가지 입장이 있다.

### 꼭 필요한 곳에만 메모이제이션을 추가 해야 한다.

- 메모이제이션에도 비용이 들어간다.
- 간단한 작업의 경우 비용이 더 들어갈 수 있다.
- 리액트 공식문서에서는 useMemo를 사용하지 않고도 작동할 수 있는 코드를 작성하는것을 권하고 있다.

### 렌더링 과정의 비용은 비싸다! 모두 메모이제이션 해버리자

- 자식컴포넌트가 많은 경우, memo를 때려버리는것이 이득이다
- 프로젝트 규모가 커지는 경우 메모이제이션이 필요한 컴포넌트만 세심하게 볼 수 없다.
- 메모이제이션 되지 않았을 경우 발생하는 리렌더링(객체 재생성)의 비용이 더 크다.
- 사람의 실수로 인한 비용 문제도 있다.

```
글쓴이도 후자에 좀 더 이점이 크다고 말했는데 저도 비슷하게 생각합니다.
작업자가 작업을 하면서 생각을 덜 하게 해주는 부분도 꽤 크다고 생각합니다. 다들 이 부분에 대해서 어떻게 생각하시나요?
```
