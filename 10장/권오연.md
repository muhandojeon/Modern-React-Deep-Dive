# 10장. 리액트 17과 18의 변경사항 살펴보기

## 10.1 리액트 17버전 살펴보기

- 16버전과 다르게 새롭게 추가된 기능은 없다.
- 16 → 17 업그레이드는 큰 변화를 겪지 않고 순조롭게 마무리 가능

### 10.1.1 리액트의 점진적인 업그레이드

- 버전업은 실무, 현업에서 매우 번거로운 작업
- 전체 웹 서비스가 새로운 버전으로 완전히 넘어가버리거나, 계속 현재(과거 버전)에 머물러 있어야 한다.
- 그런데 리액트 17버전부터는 점진적인 업그레이드가 가능해진다.
- 리액트 17을 설치하고 이후에 리액트 18로 업데이트 한다면 리액트 18에서 제공하는 대부분의 기능을 사용할 수 있지만, 일부 기능에 대해서는 리액트 17에 머물러 있는 것이 가능
- 리액트 17 앱은 내부에서 리액트 16 앱을 게으르게 불러오기 때문에 가능

### 10.1.2 이벤트 위임 방식의 변경

- 리액트에서 이벤트는 어떻게 추가되는가?
  - onClick 으로 이벤트를 추가한 경우
    - click에 noop (no operation) 이라는 함수가 달려있고 아무런 일도 하지 않음.
  - useRef를 활용해 고전적인 이벤트 핸들러 추가 방식으로 추가한 경우
    - 이벤트 리스너에 click 으로 추가됨
  → 리액트에서는 이벤트 핸들러를 각각의 DOM 요소에 부착하지 않고 하나의 핸들러를 루트에 부착해서 이벤트 위임을 활용한다. 이벤트 위임의 원리 덕분에 이벤트를 상위 컴포넌트에만 부착해도 되는 것
  → 리액트 16에서는 모든 이벤트가 document에 달려 있고, 리액트 17에서는 컴포넌트 루트에 달려있다.

### 10.1.3 import React from ‘react’ 가 더 이상 필요 없다: 새로운 JSX transform

- 리액트 17부터는 바벨과 협력해 import 구문 없이도 JSX를 변환할 수 있게 됐다.
  - 번들링 크기를 약간 줄일 수 있다는 장점

### 10.1.4 그 밖의 주요 변경 사항

- 이벤트 풀링 제거
  - 리액트는 브라우저 기본 이벤트가 아닌 한번 래핑한 이벤트 (SyntheticEvent)를 사용해 이벤트가 발생할 때 마다 이 이벤트를 새로 만들어야 했다.
- useEffect 클린업 함수의 비동기 실행
  - 16 버전까지는 클린업 함수가 동기적으로 처리.
    - → 클린업 함수가 완료되기 전까지는 다른 작업을 방해
  - 17 버전부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행
- 컴포넌트의 undefined 반환에 대한 일관적인 처리
  - 리액트 16에서는 forwardRef나 memo에서 undefined 를 반환하면 별다른 에러가 발생하지 않았지만, 17버전에서는 의도치 않게 잘못된 반환으로 인한 실수를 방지하기 위해 에러 발생 시킴. 18부터는 에러 발생 안함. ???

## 10.2 리액트 18 버전 살펴보기

### 10.2.1 새로 추가된 훅 살펴보기

- useId
  - 컴포넌트별로 유니크한 값을 생성하는 새로운 훅
  - 하나의 컴포넌트가 여러 군데에서 재사용되는 경우도 고려해야 하며, 리액트 컴포넌트 트리에서 컴포넌트가 가지는 모든 값이 겹치지 않고 다 달라야 한다는 제약
  - 서버사이드렌더링 환경에서 하이드레이션이 일어날 때, 서버와 클라이언트에서 동일한 값을 가져야 에러가 발생하지 않는 점!
  - 서버사이드와 클라이언트사이드 간에 동일한 값이 생성되어 하이드레이션 이슈도 발생하지 않음
- useTransition
  - UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅
  - 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 미룰 수 있다.
  - 타이핑으로 인해서 setState가 일어나는 경우, 타이핑이 끝날 때 까지, useTransition으로 지연시킨 상태 업데이트는 일어나지 않는다. → 오토컴플릿 같은거 만들 때, debounce 대신 써도 되려나..?
- useDeferredValue
  - 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅
  - 디바운스와 비슷
  - 차이점은 디바운스는 고정된 지연 시간을 필요로 하지만 useDeferredValue는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 useDeferredValue로 지연된 렌더링 수행
- useSyncExternalStore
  - tearing 현상을 해결하기 위한 훅
- **useInsertionEffect**
  - CSS-in-js 라이브러리를 위한 훅
  - DOM이 실제로 변경되기 전에 동기적으로 실행
  - useLayoutEffect보다 먼저 실행

### 10.2.2 react-dom/client

- createRoot
  - render 메서드를 대체할 새로운 메서드
- hydrateRoot
  - 서버 사이드 렌더링 애플리케이션에서 하이드레이션을 하기 위한 새로운 메서드

### 10.2.3 react-dom/server

- renderToPipeableStream
  - 리액트 컴포넌트를 HTML로 렌더링하는 메서드
- renderToReadableStream
  - 웹 스트림을 기반으로 작동

### 10.2.4 자동 배치(Automatic Batching)

- 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법
- 18에서 업데이트된 기능인데 이걸 쓰고 싶지 않다면 flushSync를 사용하면 된다.

### 10.2.5 더욱 엄격해진 엄격 모드

- 리액트의 엄격 모드는 리액트 앱에서 발생할 수도 있는 잠재적인 버그를 찾는데 도움이 되는 컴포넌트
- 개발자 모드에서만 작동한다. (프로덕션 모드 X)
- 더 이상 안전하지 않은 특정 생명주기(componentWillMount, componentWillReceiveProps, componentWillUpdate)를 사용하는 컴포넌트에 대한 경고
- 문자열 ref 사용 금지
- findDOMNode에 대한 경고 출력
- 구 Context API 사용 시 발생하는 경고
- 예상치 못한 사이드 이펙트 검사
  - CLASS - constructor, render, shouldComponentUpdate, getDerivedStateFromProps
  - CLASS - setState의 첫번째 인수
  - FUNCTION - body
  - useState, useMemo, useReducer에 전달되는 함수
- 18에서 업데이트 될 부분
  - useEffect 두번 실행
  - 우리는 useEffect를 쓸 때 적절한 cleanup 함수를 배치해서 반복 실행될 수 있는 useEffect로 부터 최대한 자유로운 컴포넌트를 제작하자.

### 10.2.6 Suspense 기능 강화

- Suspense는 컴포넌트를 동적으로 가져올 수 있게 도와주는 기능 (리액트 16.6 버전에서는 실험 기능)
- React.lazy로 선언한 지연 컴포넌트를 받아오기 전에는 fallback을 보여주고, 완료되면 해당 컴포넌트를 보여주는 역할

### 10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

- Promise: 비동기 연산이 종료된 이후에 실패 또는 결괏값을 확인할 수 있는 객체
- Symbol: 자바스크립트의 새로운 데이터 형식으로 익명의 객체 속성을 만들 수 있는 특성을 가진 객체
- Object.assign: 객체의 열거 가능한 모든 속성을 다른 객체로 붙여 넣는 메서드
- 이 세가지 기능이 지원되지 않는 브라우저를 고려해야 한다면 폴리필을 추가

### 10.2.9 정리

- 18 버전의 핵심은 동시성 렌더링
  - 렌더링 중간에 일시 중지, 나중에 여유가 될 때 시작하거나 진행 중인 렌더링 작업을 포기하고 새로 다시 시작도 가능
  - 동시성 모드를 활용하면서 추가적으로 라이브러리를 쓰기 위해서는 검토가 필요
