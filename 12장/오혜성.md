# 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표
* 많은 개발자들이 성능에 대해 크게 관심을 기울이지 않는 이유
  + 일반적으로 개발자의 기기는 평균적인 기기보다 성능이 뛰어남
  + 성능 개선 작업은 쉽지도, 재밌지도 않고 서비스 개발 작업 대비 눈에 띄는 성능 향상을 기대하기 어려움
  + 계속되는 업무와 버그

* 하지만 웹사이트 성능 또한 개발자의 책임이며, 성능은 조직이 이루고자 하는 목표와 직결된다고 봐도 무방

## 핵심 웹 지표 (Core Web Vital)

* Core Web Vital은 구글에서 정의한 지표
  + 이전에는 뚜렷한 표준이나 측정 방법이 정해져 있지 않았음
  + 이를 해결하기 위해 지표와 측정할 수 있는 방법, 기준을 명확하게 제시함

## LCP (Largest Contentful Paint)

* 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간

* 뷰포트 내부에서 '큰 이미지와 텍스트'
  + <img>
  + <svg> 내부의 <image>
  + poster 속성을 사용하는 <video>
  + url()을 통해 불러온 배경 이미지가 있는 요소
  + 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
    - <p>, <div> 등

* DOMContentLoaded 이벤트와는 다름
  + 위 이벤트는 스타일시트, 이미지, 하위 프레임의 로딩은 기다리지 않기 때문

### 개선 방안

* 텍스트를 쓰자
  + 이미지보다 빠르기 때문

* 이미지를 불러오는 방법
  + img 태그나 video 태그의 poster 속성이 svg와 css background-image보다 빠름
  + img와 poster 속성은 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 빠르게 요청이 일어난다
    - 프리로더 스캐너란 HTML을 파싱하는 단계를 차단하지 않고 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 찾아 로딩하는 브라우저의 기능
    - 즉 HTML 파싱 완료 이전에 병렬적으로 리소스를 다운로드함
    - 🤘 https://yceffort.kr/2022/06/preload-scanner

* 이미지 무손실 압축
* loading=lazy를 LCP 영역에서 사용하지 말 것
  + 애니메이션도 동일
* 클라이언트에서 빌드하지 말 것
* LCP 리소스는 직접 호스팅
  + 이미 연결이 맺어진 현재 출처와는 다르게, 완전히 새로운 출처의 경우 네트워크 커넥션부터 다시 수행해야 하기 때문
  

## FID (First Input Delay)

* 얼마나 빠르게 웹페이지와 상호작용에 대한 응답을 받을 수 있는지
  + 클릭, 터치, 타이핑에 초점을 두고 측정함
    - 스크롤, 핀치 투 줌은 애니메이션으로 분류해 측정 대상에서 제외

* 이벤트 반응은 왜 늦어질까?
  + 브라우저의 메인 스레드가 바쁘기 때문
    - 왜 바쁠까?
      - 대규모 렌더링이 일어나고 있거나
      - 자바스크립트 파일을 분석, 실행하거나

* 최초 이벤트 발생부터 해당 이벤트의 핸들러가 실행되는 순간까지 사이의 기간만 측정함
  + 이벤트 핸들러가 완료되는 데 걸리는 시간은 Event Timing API를 통해 측정할 수 있음
  + https://www.w3.org/TR/event-timing/

### RAIL

구글은 사용자 경험을 크게 4가지로 분류해 정의함

* Response: 입력에 대한 반응 속도, 50ms
* Animation: 애니메이션의 프레임 속도, 10ms
* Idle: 유휴 시간을 활용해 페이지가 50ms 이내에 사용자 입력에 반응할 수 있도록 함
* Load: 5s 이내에 콘텐츠를 전달하고 인터랙션을 준비

### 개선 방안

* 실행에 오래 걸리는 긴 작업을 분리
  + 꼭 웹페이지에서 해야 하는 작업? -> 서버에 옮겨서 처리
  + 긴 작업을 여러 개로 분리

* 자바스크립트 코드 최소화
  + 번들링이 되지만, 여전히 사용하지 않는 코드가 존재할 수 있음
  + 크롬 개발자 도구의 커버리지를 활용할 수 있음

* 타사 자바스크립트 코드 실행의 지연
  + GA, Firebase 등 써드 파티 스크립트
  + script 태그의 async, defer 속성을 이용
    - defer: 다른 리소스와 함께 병렬로 다운로드. 다운로드가 완료됐다 하더라도 페이지가 완전히 로딩된 이후에 맨 마지막에 실행 됨
    - async: 다른 리소스와 함께 병렬로 다운로드. 다운로드가 완료되면 즉시 실행됨
    - 둘 다 없는 경우: script를 만나는 순간 다운로드. 다운로드가 완료되면 코드 실행이 우선됨. 다른 작업은 다운로드와 실행이 끝날 때까지 미뤄짐

## CLS (Cumulative Layout Shift)

* 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지푤르 계산하는 것

> 유튜브의 경우 최초 서버 사이드에서 가져온 HTML에서는 어떤 영상이 나올지 결정돼 있지 않은 채로 렌더링 됨

### 개선 방안

* 삽입이 예상되는 요소를 위한 추가적인 공간 확보
  + 서버 사이드 렌더링
  + 스켈레톤 UI
  + useEffect 사용이 불가피하다면 layoutEffect 사용 검토
    - 하지만 동기적으로 동작해, 렌더링 성능에 영향을 줄 수 있음

* 폰트 로딩 최적화
  + 폰트는 각각 고유의 높이와 너비를 가지고 있음. 
    - 기본 폰트로 먼저 렌더링되거나, 노출하지 못해서 누적 레이아웃 이동이 발생할 수 있음
  + <link> preload 사용
  + `font-display: optional`
    - 🤘 책에서는 패밀리로 나오는데, 디스플레이겠죠?
    - optional - 100ms간 텍스트가 보이지 않고 이후 폴백 폰트로 렌더링함
      - 🤘 https://drafts.csswg.org/css-fonts/#font-display-desc

* 이미지 크기 설정
  + `height: auto`는 원본 이미지 비율을 쉽게 보여줄 수 있지만, 레이아웃 이동이 발생할 수 있음
  + img의 width, height 속성을 사용해 비율을 알려주기
  + 만약 뷰포트 너비에 맞춰 다른 이미지를 제공하고 싶다면, srcset을 이용

## TTFB (Time to First Byte)

* 최초 바이트까지의 시간

### 개선 방안

  
* 서버 사이드 렌더링을 한다면 로직을 최적화

> 🤘 서버 사이드에서 이미지를 만드는 동작이 있고, 거기서 폰트를 다운로드 하느라
> TTFB가 엄청 느려진 이슈가 있었는데요
> 위 기능을 API route로 옮기고, 클라이언트에서 호출해 속도를 개선한 경험을 공유드려용
> https://github.com/depromeet/na-lab-client/pull/451

* 주된 사용자의 국적과 가깝게 서버 위치시키기

* 서버 사이드 렌더링 시 stream 기반 api 사용

## FCP (First Contentful Paint)

* 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠 일부가 화면에 렌더링될 때까지의 시간

### 개선 방안

* TTFB 개선

* 렌더링을 가로막는 리소스 최소화

* above the fold에 대한 최적화
  + above the fold?
    - 스크롤을 하지 않아도 보이는 영역

* 리다이렉트 최소화

* DOM 크기 최소화
  + 구글 기준에 따르면
    - DOM 노드는 1500개 미만
    - 깊이는 32단계
    - 부모 노드는 자식 노드를 60개 정도만
  + 이보다 크고 복잡하다면 브라우저가 이를 파악하고 렌더링하는 데 시간이 오래 걸림

## 정리

아무리 좋은 콘텐츠가 제공되고 있다 하더라도 사용자의 환경은 생각보다 성능이 열악하며, 속도는 느리고, 인내심도 많지 않다

0.1 ~ 0.2초 차이만으로도 사용자에게 큰 차이를 느끼게 해줄 수 있다
