# 1장 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 1.1 자바스크립트의 동등 비교

* 리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 props의 동등 비교이다.
  + props의 동등 비교는 객체의 얕은 비교를 기반으로 이루어진다

* 리액트의 동등 비교는 Object.is를 이용한다
  + Object.is는 ES6에서 제공하는 기능이기 때문에, 리액트에서는 폴리필을 함꼐 사용한다

* 리액트에서의 비교는 Object.is로 먼저 비교한 다음에, 객체 간 얕은 비교를 한 번 더 수행한다
  + `shallowEqual`

### 1.1.1 데이터 타입

* 객체와 배열은 내부에 값이 존재하는지 여부와 상관없이 truthy한 값으로 취급된다

* Bigint

```js
const a = 123n;
const b = 123;

a == b // true
a === b // false
```

### 1.1.2 저장하는 방식의 차이

* 원시 타입과 객체 타입의 가장 큰 차이점은 값을 저장하는 방식의 차이
  + 원시 타입은 불변 형태의 값으로 저장, 객체 타입은 가변 형태의 값(참조)으로 저장

### 1.1.3 Object.is

* `== vs Object.is`

  + ==는 타입 캐스팅을 한 후에 비교한다
  + Object.is는 하지 않음

* `=== vs Object.is`
  + ===는 +0과 -0을 같다고 판단하지만, Object.is는 다르다고 판단한다
  + NaN은 ===로 비교할 수 없지만, Object.is는 같다고 판단한다

## 1.2 함수

* 프로그래밍 세계에서 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다

* `arguments.callee.`
  + 함수 몸통에서 현재 실행 중인 함수를 참조하는 데 사용할 수 있다
  + https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee

### 함수 호이스팅

* 함수 선언문은 미리 메모리에 등록, 순서에 상관없이 정상적으로 호출됨
* 함수 표현식도 호이스팅이 발생하지만, 호이스팅 시점에서 undefined로 초기화됨

### 화살표 함수

* constructor를 사용할 수 없음
* arguments가 존재하지 않음
* 예측 가능한(선언 시점에 결정되는) this 바인딩

### 1.2.3 다양한 함수

* 즉시 실행 함수는 그 선언만으로도 실행이 거기서 끝난다는 것을 각인시킬 수 있다. 재사용되지 않고 단 한 번만 실행되고 끝난다면 사용을 검토하자

### 1.2.4 주의 사항

* 어떻게서든 항상 순수 함수로만 작성해야 할까?
  + 웹 애플리케이션을 만드는 과정에서 부수 효과는 어떻게 보면 피할 수 없는 요소다
  + 자바스크립트 함수에서는 가능한 한 부수 효과를 최소화하고 함수의 실행과 결과를 최대한 예측 가능하도록 설계해야 한다

* useEffect 콜백 함수에 이름을 붙이기

## 1.3 클래스

* `set`,  `get` 키워드
* `static` 절적 메서드는 클래스에서 직접 호출한다
  + 정적 메서드 내부의 this는 클래스로 생성된 인스턴스가 아닌, 클래스 자신을 가리킨다.

* 프로퍼티에 `#`을 붙여서 pricate로 선언하는 방법이 ES2019에 추가됨
  
* 인스턴스 메서드는 실제로 자바스크립트의 prototype에 선언되므로 프로토타입 메서드로 불림

* `__proto__`는 과거 브라우저가 이를 사용했기 때문에 호환성을 지키기 위해서만 존재한다
  + `Object.getPrototypeOf`를 사용하자
  

## 1.4 클로저

* 클로저는 함수와 함수가 선언된 어휘적 환경의 조합

* 클로저를 활용해 전역 스코프의 사용을 막고, 개발자가 원하는 정보만 원하는 방향으로 노출시킬 수 있는 장점이 있다
  
* 클로저가 useState 내부에서 활용됐기 때문에 setState는 useState 내부의 최신 값을 어떻게 계속해서 확인할 수 있다

## 1.5 이벤트 루프와 비동기 통신의 이해

* 리액트는 과거 렌더링 스택을 비우는 방식으로 구현됐던 동기식의 렌더링이 16버전으로 접어들면서 비동기식으로 작동하는 방법으로 변경됐다
  

### 싱글 스레드

* 95년 상황을 빗대어 보았을 때 자바스크립트를 싱글 스레드 언어로 구현한 것은 나름 합리적인 결정으로 볼 수 있다.

### 이벤트 루프

* 이벤트 루프는 ECMAScript 표준에 정의된 내용이 아니다
  + 런타임 외부에서 비동기 실행을 돕기 위해 만들어진 장치라 볼 수 있다

* 태스크 큐란 실행해야 할 태스크의 집합을 의미한다
  + 이름과 다르게 자료구조 큐가 아닌, set의 형태를 띠고 있다
  + 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하기 때문이다

* 마이크로 태스크 큐는 태스크 큐보다 우선권을 갖는다
  + 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행은 뒤로 미루어진다
  + 대표적으로 Promise가 속한다

```
마이크로 태스크 큐: process.nextTick, Promises, queueMicrotask, MutationObserver
태스크 큐: setTimeout, setInterval, setImmediate
```

* 브라우저에 렌더링하는 작업은 마이크로 태스크 큐와 태스크 큐 사이에서 일어난다

## 1.6 리액트에서 자주 사용하는 자바스크립트 문법

### 구조 분해 할당

* 배열 분해 할당의 기본값
  

```js
  const [a = 1, b = 2] = arr;
```

  + undefined인 경우에만 기본값을 사용한다
  - 

* 객체 분해 할당의 기본값
  

```js
  const {
      a = 1, b = 2
  } = obj;
```

  + 트랜스파일 시 코드의 양이 길어진다
  + 객체 내부에서 심벌의 존재를 확인할 수 있는 경우를 대비해 이에 대한 예외 처리를 추가로 해주고 있다

### 전개 구문

* 배열 전개 구문 시 concat을 이용한 방법으로 트랜스파일 된다
* 객체 전개 구문은 객체의 속성 값 및 설명자 확인, 심벌 체크 등 때문에 트랜스파일된 코드가 커진다

### 삼항 연산자

* JSX 내부에서 삼항 연산자 말고, 즉시 실행 함수를 이용해 조건부 렌더링을 구현할 수 있다

## 1.7 타입스크립트

* 페이스북에서 만든 yarn, jest도 flow가 아닌 타입스크립트로 재작상됐다

* 일반적으로 제네릭을 알파벳 T, U 등으로 표현하는 경욱 ㅏ많은데, 의미하는 바를 명확히 하기 위해 적절하게 네이밍하는 것이 좋다

### 덕 타이핑

* Object.keys는 타입스크립트의 구조적 타이핑 특징 때문에 `string[]`을 반환한다

* 덕 타이핑이란 객체의 타입이 클래스 상속, 인터페이스 구현 등으로 결정되는 것이 아니고 어떤 객체가 필요한 변수와 메서드만 지니고 있다면 그냥 해당 타입에 속하도록 인정해 주는 것을 의미한다

* 그럼에도 일부 개발자들은 정확한 타입을 반환하는 Exact라는 새로운 타입을 요청하고 있다

### 전환 가이드

* 파일 최상단에 `//@ts-check`를 선언하고 JSDoc을 활용해 변수나 함수에 타입을 제공하면 타입스크립트 컴파일러가 자바스크립트 파일의 타입을 확인한다
