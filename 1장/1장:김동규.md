# Modern React Deep Dive 1주차



## 내용정리

- 리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 바로 props의 동등 비교에 따른 결과다. 그리고 이 props의 동등 비교는 객체의 얕은 비교를 기반으로 이뤄진다. 
- 자바스크립트의 원시 타입에는 `boolean` `null`  `undefined` `number` `string` `symbol` `bigint` 가 있다.
- 원시 타입과 객체 타입의 값을 저장하는 방식의 차이가 동등 비교를 할 때 차이를 만드는 원인이다.
- 원시 타입은 불변 행태 값으로 저장, 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다. 반대로 객체는 값이 아닌 참조를 저장한다.
- Object.is는 ===와 동일하게 타입이 다르다면 그냥 false이다. 하지만 객체 비교에는 별 차이 없다.
- 리액트에서는 Object.is를 사용하여 비교를 하고, ES6 문법이기에 폴리필도 같이 가지고 있다. 실제로 리액트에서  `shallowEqual` 이라는 함수로 만들어 사용하고 있고, 단순히 Object.is 만 사용하는 것이 아닌 객체 비교도 같이 진행하고 있다. 1차로 Object.is를 통한 비교를 진행하고 얕튼 비교를 한번 더 수행한다.
- shallowEqual 함수는 얕은 비교 까지만 진행하기 때문에 컴포넌트 props를 통한 Object 데이터가 넘어 오는 경우 비교하지 않기 때문에 메모이제이션이 적용 될 수 없다. 즉, 성능에 문제가 발생할 수 있다.
-  객체 비교를 완벽하게 하기 위해서 얼마나 많은 재귀함수가 추가되어야할 지 모르기에 1deps의 얕은 비교만 진행 한다. 이런 객체 비교 불완전성은 JS에서의 특징임으로 JS 개발자라면 잘 알고 있어야한다.
- 함수 선언문, 함수 표현식은 호이스팅에 따른 차이가 있지만, 어떤게 더 좋다고 할 수는 없다. 상황에 따라 쓰도록!
- 함수 생성자 방식은 eval 만큼 쓰지 않는 방법이다.
- 화살표함수는 constructor를 사용할 수 없다. this 바인딩도 다른 함수 선언방식과 차이가 있다.
- this는 자신이 속한 객체나 자신이 생성할 인스턴스를 가르키는 값이다.
- 함수를 만들때 규칙은 Side-Effect를 최대한 억제하고, 최대한 작게만들고, 누구나 이해할 수 있는 이름을 붙이면 된다.
- 클래스에 대해 이해한다면, 리액트가 왜 함수형으로 변경했는지 알 수 있다.
- \_\_proto\_\_는 과거 브라우저 호환성을 지키기 위해서 사용하는것으로 사용하지 않는다.
- 클로저는 함수와 함수가 선언된 어휘적 환경의 조합 이라는 정의를 같고 있다. React에서 useState가 대표적인 클로저의 예시이다.
- 큰 작업을 하는 경우, 함수의 선언적 환경을 기억해야 하기 때문에 클로저는 비용이 많이 들어가게 된다.
- 결국 클로저는 외부 함수를 기억하고 이를 내부함수에서 가져다 쓰는 메커니즘 이다. 부수 효과가 없고 순수해야 한다라는 목적을 달성하기 위해 적극적으로 사용 되는 개념이다.
- 자바스크립트는 싱글 스레드 언어 이고, 당시에 상황에 맞게 설계되었다.
- 이벤트 루프의 역할은 호출 스택에 실행 중인 코드가 있는지, 그리고 테스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할이다
- 테스크큐는 선택된 큐 중 실행ㄹ 가능한 가장 오래된 테스크를 가져와야 하기 때문에 큐가 아닌 set 형태를 띄고 있다.
- 마이크로 테스크 큐는 테스트 큐 보다 우선권이 있고, Promise 같은 것들이 있다. 마이크로 테스트 큐가 비워질 때 까지 테스트 큐의 실행은 뒤로 미뤄진다.
- 마이크로 테스트 큐의 작업이 끝날 때 마다 렌더링을 하게 된다. 각 마이크로 테스트 큐 작업이 끝날 때 마다 한번 씩 렌더링 할 기회를 얻는다.
- 배열 구조 분해 할당에서는 undefined일 경우에만 기본값을 사용한다.
- forEach는 무조건 O(n) 만큼 실행되기 때문에 코드 작성과 실행 시에 반드시 최적화할 가능성이 있는지 검토해보아야 한다.
- 타입스크립트 any 대신 unknown을 사용하자. type narrowing을 통해 타입을 좁힌 후 사용해야 하기 때문에 any보다 안전하게 코딩이 가능하다.
- instanceof 및 typeof 같은 타입 가드를 적극 사용하는게 좋다.
- in을 활용하여 특정 객체에만 있는 프로퍼티 값을 확인하고 좁혀서 사용할 수 있다.
- 인덱스 시그니처를 통해 동적으로 객체의 키를 생성하는 것을 최대한 지양해야한다. Record 및 타입을 사용한 인덱스 시그니처를 통해 객체를 원하는 형태로 좁힐 수 있다.
- Object.keys는 string[] 타입으로 강제 할당되어 있다.
- 덕타이핑은 객체의 타입이 클래스 상속, 인터페이스 구현 등으로 결정되는 것이 아니라 특정 객체가 필요한 변수와 메서드만 지니고 있다면 해당 타입에 속하도록 인정해주는 것 이다.



## 새로 알게 된 것

- ` 요걸 백틱이라고 부른다고 합니다. 
- typeof null === null 을 실제로 구현하려고 하던 시도가 있었으나, breaking change 문제로 받아들여지지 않았다.
- shallowEqual 함수의 존재
- Vue2에서도 Object 타입의 데이터에 신규 프로퍼티를 추가하려거나 했으면 this.$set 형식으로 별도 함수를 통해 추가해줘야 됬는데 어느 프레임워크든 객체의 비교 부분에서 고민하고 있는 부분이 많은 것 같네요
- Function 생성자, 쓰지 않아서 다행이라고 생각합니다.
- 새롭게 알게 된 건 아니지만, class형 컴포넌트 예제를 보았는데 this 기반으로 무언가를 제어하는건 생각을 한번 더 해야하는 번거로움이 생기는 것 같긴합니다.. Vue2에서도 this.xx로 제어를 많이 하는데 화살표 함수를 사용해야하는 경우 번거롭게 사용하는 경우도 있었어서 적어봅니다. 

```
methods:{
	// Vue2에서 화살표 함수 사용할 때 이렇게 사용했습니다 ㅋㅋ...
	test(){
		const vm = this;
		const calc = () =>{
			vm.state = 'new'
		}
	}
}
```

- Babel 트랜스파일 하는 경우 화살표함수는 상위에 _this를 만들고 함수 내부의 _this를 undefiend로 바꾸는 모습
- Taser가 설치되어 있으면 한글로 네이밍해도 되는 부분?? 
- useState를 포함한 React의 많은 부분들이 클로저를 통해서 구현 되고 있다라는 것과 클로저의 대략적인 개념에 대해서 알게 되었습니다.
- 마이크로 테스크 큐가 끝나고 렌더링의 기회가 있다라는 사실. 



## 이해 안되거나 조금 더 찾아봐야 될 부분

- Object.is의 정확한 비교 조건
- 다른 React hook들은 어떤식으로 클로저를 활용하고 있는지?
- 테스트 큐, 마이크로 테스트큐 와 브라우저 렌더링 과정의 상관관계



## 궁금증

- Bigint가 Number의 숫자 크기 제한을 극복하기 위해 생겨났는데, 모든걸 Bigint로 쓰면 안되는 것 일까?
- Bigint를 사용하는 경우 성능상의 문제는 없을까? 실제 우리가 사용하는 프로젝트에서는 얼만큼 영향을 미칠까?
- Symbol을 이용해서 우리가 사용하는 UUID를 대체할 수 는 없을까?
- 객체의 깊은 비교가 되지 않기 때문에 리액트에서는 Props로 Object 타입을 넘기거나 데이터를 Object 타입으로 쓰는것이 안티패턴일까?

- 종종 오픈소스나 다른 코드들에서 아래와 같은 방식으로 파라미터를 자유롭게 받아서 사용하는 경우도 있던데, 다들 사용하시는지 궁금합니다.. 리액트에서 `...props` 로 사용하는 방식이 떠오르기는 하는데, 저는 ts 기반의 프로젝트에서는 항상 타입을 지정해서 사용하거든요!

```
function Hello(){
	console.log(arguments)
}
```

- 다들 즉시실행 함수를 많이 쓰시나요? 일회성으로 쓸 수 있다라는 점이 유용할 것 같은데 리액트에서 일회성으로 쓰시는 다른 방법들이 있는지 궁금합니다.
- Taser 한글 변수명에 대한 언급(번들링 속도에는 약간 부담이 될 수 있지만..) 때문에 궁금한 점이 있는데 "개발자가 코드 작성을 위해 성능 혹은 번들링 속도를 조금 포기할 수 있다" 라는 의견에 동의하시나요 비동의 하시나요?
